# 실제 개념
## 인터럽트 처리란
인터럽트 처리란, CPU가 정상적인 실행 흐름을 잠시 중단하고,
외부 또는 내부에서 발생한 긴급 이벤트를 즉시 처리한 뒤,
아무 일도 없었던 것처럼 원래 실행 흐름으로 복귀하는 메커니즘입니다.

인터럽트는 현재 실행 중이던 코드보다 높은 우선순위로 처리되므로,
다음과 같은 성격의 이벤트에 적합합니다.
`: 놓치면 안 되고, 언제 발생할지 예측할 수 없으며,
지연 없이 즉각적인 반응이 필요한 이벤트`

### 인터럽트에 적합한 이벤트 예시
* 통신 이벤트
  * UART RX/TX 완료, SPI/I2C 전송 완료, CAN/LIN 메시지 수신
  * 데이터 유실 위험이 있고 즉시 반응이 필요함
* 타이머 이벤트
  * 주기 제어 타이머, 시스템 tick
* 외부 신호 이벤트
  * 버튼 입력, 외부 IC 인터럽트 핀, 센서 threshold 초과
  * polling으로 놓치기 쉬운 이벤트들
* 하드웨어 완료 알림
  * ADC 변환 완료, DMA 전송 완료, EEPROM 쓰기 완료

반대로, "계속 상태를 확인해야 하는 센서 값 읽기", "상태 유지 체크" 등은 폴링이 더 적합하며, 
고속 ADC 샘플링처럼 발생 빈도가 매우 높은 이벤트는 인터럽트 대신 DMA+버퍼+태스크 구조가 적합합니다.

### 인터럽트 vs polling 비교 
인터럽트는 이론적으로 폴링 (`while(1)`)으로도 구현이 가능하지만,
* CPU 낭비 (계속 조건을 확인해야 함)
* 응답 지연 (앞선 코드 실행이 끝나야 확인 가능

이라는 한계가 있습니다.

인터럽트는 필요할 떄만 CPU를 깨우고, 즉시 실행 흐름을 전환할 수 있기 문에 실시간 이벤트 처리에 적합합니다.

## 인터럽트 처리 순서
인터럽트 진행은 항상 CPU 파이프라인을 중단(flush)하고 실행 흐름을 전환합니다.
### 1. 이벤트 발생 
* 예: 타이머 완료, GPIO 변화, UART 수신 등의 이벤트 발생
* 하드웨어가 인터럽트 요청을 pending 상태로 표시합니다.
### 2. 현재 명령어 마무리 (commit)
* CPU는 현재 실행 중이던 “하나의 명령어”만 끝까지 완료합니다.
  * 레지스터/메모리에 아키텍처적으로 반영된 결과까지만 보장
  * 중간에 실행 중이던 다른 명령어들은 아직 커밋되지 않음
  
### 3. 파이프라인 정리 (flush)
* 현재 명령어를 제외하고, 파이프라인에 들어와 있던 나머지 명령어들은 모두 무효화(flush) 됩니다.
  * 아직 WB 단계가 아닌 명령어들은 되돌릴 것도, 저장할 것도 없기 떄문에 폐기합니다. 

### 4. 컨텍스트 저장 (자동)
* ISR 실행 후 원래 코드로 돌아오기 위해, CPU는 현재의 안정된 실행 상태(context)를 저장합니다.
* 해당 context들은 stack에 저장되거나, 전용 컨텍스트 저장 구조에 저장합니다. (**Aurix의 경우 CSA**에 저장)
#### 컨텍스트란
CPU가 자기 상태라고 인식하는 정보인 PC (복귀할 명령어 주소), PSW / SR (상태 레지스터), R0 ~ Rn (일부 일반 레지스터)의 값입니다.

### 5. ISR 진입
CPU는 하드웨어적으로 정의된 인터럽트 벡터 테이블을 참조하여 다음을 진행합니다. 이 과정에는 소프트웨어의 개입이 없습니다.
1. 인터럽트 번호 확인
2. 벡터 테이블에서 ISR 시작 주소 읽기
3. PC를 ISR 주소로 변경
4. 실행흐름 전환

### 6. ISR 실행 
#### ISR이란
* Flash / ROM 에 저장된 일반 코드입니다. RISC 명령어 흐름과 동일하게 동일한 파이프라인 단계를 거쳐 실행됩니다.
* 다만, 함수 호출이 아니라 하드웨어에 의해 강제로 진입한다는 점이 다릅니다.
### 7. 컨텍스트 복원
ISR 마지막에 실행되는 특수 복귀 명령 (RTI / IRET)는 다음을 진행합니다.
1. 저장된 PC / 상태 레지스터 복원
2. 인터럽트 이전 상태로 CPU 복구

### 8. 원래 코드로 복귀
복원된 PC 기준으로 원래 실행 흐름을 처음부터가 아닌, 중단되었던 파이프라인 시점을 다시 채워서 그대로 재개합니다.

## 그 외 개념
### 인터럽트 종류
1. 하드웨어 인터럽트
   * 외부 또는 주변 장치에서 발생하는 인터럽트입니다.
   * 예: GPIO, UART, 타이머, DMA 완료, 키보드 입력, 마우스 클릭, 디스크 쓰기 완료
2. 소프트웨어 인터럽트
   * 프로그램이 명시적으로 발생시키는 인터럽트입니다
   * 예: 시스템 콜, Trap
3. 예외
   * CPU가 명령어를 실행 중에 오류 감지할 때 발생한는 인터럽트입니다.
   * 예: 0으로 나누기 오류, 잘못된 메모리 주소 접근, 전원 공급 이상

### 인터럽트 지연
* 이벤트 발생부터 ISR 첫 명령 실행까지 걸리는 시간입니다.
* 현재 명령어 완료, 파이프라인 flush, 컨텍스트 저장, 벡터주소 읽기, PC 변경 물리적인 순서대로 진행하기까지 수십~수백 클록이 소요됩니다.
### 인터럽트 우선순위
* 인터럽트마다 중요도가 있습니다. 높은 우선순위는 낮은 ISR을 중단(nesting)할 수 있습니다.
* 중첩이 많을수록 스택 사용 증가하고, WCET 계산이 어려워집니다. 

# 내가 이해한 바 
# 개발자 관점에서 신경쓸 점 
## 1. ISR을 짧고 단순하게 짠다.
아래는 나쁜 예시로, ISR 안에서 delay 사용하지 않는다. 
```C
void Timer_ISR(void) // ISR 시작 -> CPU 파이프라인 중단
{
    GPIO_Toggle(LED_PIN);
    delay_ms(100);   // 시스템 전체가 잠깐 멈춘 상태
}
```
좋은 예시로는 플래그만 설정하는 방법이 있다. 즉, ISR을 알림으로만 이해하고, 실제 작업은 메인 루프에서 진행한다. 
```C
volatile bool led_toggle_req = false;

void Timer_ISR(void)
{
    led_toggle_req = true;   // 플래그만 설정
}

int main(void)
{
    while (1)
    {
        if (led_toggle_req)
        {
            led_toggle_req = false;
            GPIO_Toggle(LED_PIN);
        }
    }
}
```
## 2. 인터럽트 우선순위는 시간 제약 기준으로 결정한다. 
우선순위가 충돌하지 않도록 하고, 높은 우선순위 ISR이 너무 많으면 낮은 우선순위가 starving 상태로 가는 것을 유의한다. 
* 우선순위 높은 기준: 지연되면 사고나거나 오동작 나는 것 (예: Motor Control Timer - 1ms deadline)
* 우선순위 낮은 것: 조금 늦어도 되는 것

## 3. 공유자원을 보호한다. 
아래 예시처럼 volatile을 쓰지 않으면 컴파일러의 최적화에 의해 `data_ready` 값을 레지스터에 캐싱하게 되어, main은 ISR 변경을 모를 수도 있다. 
```C
bool data_ready = false; // volatile 사용 필요

void ADC_ISR(void)
{
    data_ready = true;
}

int main(void)
{
    while (1)
    {
        if (data_ready)   // 컴파일러가 값 고정해버릴 수 있음
        {
            process_data();
            data_ready = false;
        }
    }
}
```

또한, ISR과 Main이 둘 다 접근하는 변수는 중간에 인터럽트 발생 시 값이 꼬일 수 있다. 
```C
volatile int counter = 0;

void Timer_ISR(void)
{
    counter++;   // ❌
}

int main(void)
{
    if (counter > 10)
    {
        counter = 0;   // ❌
    }
}
```
따라서 임계구역을 설정하여 개선한다. (또는 아토믹 연산, RTOS mutex를 사용할 수도 있다.)
```C
DisableInterrupts();
counter = 0;
EnableInterrupts();
```
## 4. 인터럽트 빈도를 너무 짧거나 과도하지 않도록 관리한다. 
아래 예시처럼 초당 10만번 ISR을 설계하면 CPU는 계속 인터럽트를 처리하느라 메인 루프는 거의 실행이 안됩니다. 
```C
// 10us 타이머
void Timer_ISR(void)
{
    do_something();
}
```
이럴 떄, 주기를 재설계하는 것이 필요합니다.
```C
// 1ms 타이머
void Timer_ISR(void)
{
    tick_1ms = true;
}
```
```C
if (tick_1ms)
{
    tick_1ms = false;
    scheduler_run();
}
```

## 5. ISR 설계 한 줄 요약
* ISR은 알림
* 계산은 밖에서
* 빈도는 최소한
* 우선순위는 시간 기준
* 공유 자원은 의심부터

# 기술지원/고객 대응 관점에서 신경쓸 점 
# 개선된 점 / 깨달음

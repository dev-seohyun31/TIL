# 실제 개념
## 인터럽트 처리란
인터럽트 처리란, CPU가 정상적인 실행 흐름을 잠시 중단하고,
외부 또는 내부에서 발생한 긴급 이벤트를 즉시 처리한 뒤,
아무 일도 없었던 것처럼 원래 실행 흐름으로 복귀하는 메커니즘입니다.

인터럽트는 현재 실행 중이던 코드보다 높은 우선순위로 처리되므로,
다음과 같은 성격의 이벤트에 적합합니다.
`: 놓치면 안 되고, 언제 발생할지 예측할 수 없으며,
지연 없이 즉각적인 반응이 필요한 이벤트`

### 인터럽트에 적합한 이벤트 예시
* 통신 이벤트
  * UART RX/TX 완료, SPI/I2C 전송 완료, CAN/LIN 메시지 수신
  * 데이터 유실 위험이 있고 즉시 반응이 필요함
* 타이머 이벤트
  * 주기 제어 타이머, 시스템 tick
* 외부 신호 이벤트
  * 버튼 입력, 외부 IC 인터럽트 핀, 센서 threshold 초과
  * polling으로 놓치기 쉬운 이벤트들
* 하드웨어 완료 알림
  * ADC 변환 완료, DMA 전송 완료, EEPROM 쓰기 완료

반대로, "계속 상태를 확인해야 하는 센서 값 읽기", "상태 유지 체크" 등은 폴링이 더 적합하며, 
고속 ADC 샘플링처럼 발생 빈도가 매우 높은 이벤트는 인터럽트 대신 DMA+버퍼+태스크 구조가 적합합니다.

### 인터럽트 vs polling 비교 
인터럽트는 이론적으로 폴링 (`while(1)`)으로도 구현이 가능하지만,
* CPU 낭비 (계속 조건을 확인해야 함)
* 응답 지연 (앞선 코드 실행이 끝나야 확인 가능

이라는 한계가 있습니다.

인터럽트는 필요할 떄만 CPU를 깨우고, 즉시 실행 흐름을 전환할 수 있기 문에 실시간 이벤트 처리에 적합합니다.

## 인터럽트 처리 순서
인터럽트 진행은 항상 CPU 파이프라인을 중단(flush)하고 실행 흐름을 전환합니다.
### 1. 이벤트 발생 
* 예: 타이머 완료, GPIO 변화, UART 수신 등의 이벤트 발생
* 하드웨어가 인터럽트 요청을 pending 상태로 표시합니다.
### 2. 현재 명령어 마무리 (commit)
* CPU는 현재 실행 중이던 “하나의 명령어”만 끝까지 완료합니다.
  * 레지스터/메모리에 아키텍처적으로 반영된 결과까지만 보장
  * 중간에 실행 중이던 다른 명령어들은 아직 커밋되지 않음
  
### 3. 파이프라인 정리 (flush)
* 현재 명령어를 제외하고, 파이프라인에 들어와 있던 나머지 명령어들은 모두 무효화(flush) 됩니다.
  * 아직 WB 단계가 아닌 명령어들은 되돌릴 것도, 저장할 것도 없기 떄문에 폐기합니다. 

### 4. 컨텍스트 저장 (자동)
* ISR 실행 후 원래 코드로 돌아오기 위해, CPU는 현재의 안정된 실행 상태(context)를 저장합니다.
* 해당 context들은 stack에 저장되거나, 전용 컨텍스트 저장 구조에 저장합니다. (**Aurix의 경우 CSA**에 저장)
#### 컨텍스트란
CPU가 자기 상태라고 인식하는 정보인 PC (복귀할 명령어 주소), PSW / SR (상태 레지스터), R0 ~ Rn (일부 일반 레지스터)의 값입니다.

### 5. ISR 진입
CPU는 하드웨어적으로 정의된 인터럽트 벡터 테이블을 참조하여 다음을 진행합니다. 이 과정에는 소프트웨어의 개입이 없습니다.
1. 인터럽트 번호 확인
2. 벡터 테이블에서 ISR 시작 주소 읽기
3. PC를 ISR 주소로 변경
4. 실행흐름 전환

### 6. ISR 실행 
#### ISR이란
* Flash / ROM 에 저장된 일반 코드입니다. RISC 명령어 흐름과 동일하게 동일한 파이프라인 단계를 거쳐 실행됩니다.
* 다만, 함수 호출이 아니라 하드웨어에 의해 강제로 진입한다는 점이 다릅니다.
### 7. 컨텍스트 복원
ISR 마지막에 실행되는 특수 복귀 명령 (RTI / IRET)는 다음을 진행합니다.
1. 저장된 PC / 상태 레지스터 복원
2. 인터럽트 이전 상태로 CPU 복구

### 8. 원래 코드로 복귀
복원된 PC 기준으로 원래 실행 흐름을 처음부터가 아닌, 중단되었던 파이프라인 시점을 다시 채워서 그대로 재개합니다.

## 그 외 개념
### 인터럽트 종류
1. 하드웨어 인터럽트
   * 외부 또는 주변 장치에서 발생하는 인터럽트입니다.
   * 예: GPIO, UART, 타이머, DMA 완료, 키보드 입력, 마우스 클릭, 디스크 쓰기 완료
2. 소프트웨어 인터럽트
   * 프로그램이 명시적으로 발생시키는 인터럽트입니다
   * 예: 시스템 콜, Trap
3. 예외
   * CPU가 명령어를 실행 중에 오류 감지할 때 발생한는 인터럽트입니다.
   * 예: 0으로 나누기 오류, 잘못된 메모리 주소 접근, 전원 공급 이상

### 인터럽트 지연
* 이벤트 발생부터 ISR 첫 명령 실행까지 걸리는 시간입니다.
* 현재 명령어 완료, 파이프라인 flush, 컨텍스트 저장, 벡터주소 읽기, PC 변경 물리적인 순서대로 진행하기까지 수십~수백 클록이 소요됩니다.
### 인터럽트 우선순위
* 인터럽트마다 중요도가 있습니다. 높은 우선순위는 낮은 ISR을 중단(nesting)할 수 있습니다.
* 중첩이 많을수록 스택 사용 증가하고, WCET 계산이 어려워집니다. 

# 내가 이해한 바 
# 개발자 관점에서 신경쓸 점 
## 1. ISR을 짧고 단순하게 짠다.
아래는 나쁜 예시로, ISR 안에서 delay 사용하지 않는다. 
```C
void Timer_ISR(void) // ISR 시작 -> CPU 파이프라인 중단
{
    GPIO_Toggle(LED_PIN);
    delay_ms(100);   // 시스템 전체가 잠깐 멈춘 상태
}
```
좋은 예시로는 플래그만 설정하는 방법이 있다. 즉, ISR을 알림으로만 이해하고, 실제 작업은 메인 루프에서 진행한다. 
```C
volatile bool led_toggle_req = false;

void Timer_ISR(void)
{
    led_toggle_req = true;   // 플래그만 설정
}

int main(void)
{
    while (1)
    {
        if (led_toggle_req)
        {
            led_toggle_req = false;
            GPIO_Toggle(LED_PIN);
        }
    }
}
```


# 기술지원/고객 대응 관점에서 신경쓸 점 
# 개선된 점 / 깨달음

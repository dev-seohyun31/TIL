# 11장. 자주 쓰는 서버 구조와 설계 패턴 — 스터디 노트

---

# 🧭 ① 이론 중심 정리 — 자주 쓰는 서버 구조와 설계 패턴

## 1️⃣ MVC 패턴 (Model–View–Controller)

- **구성요소**
  - **Model:** 비즈니스 로직 수행 (회원가입, 주문 처리, 암호 변경 등)
  - **View:** 사용자에게 보여질 결과 생성 (HTML, JSON 등)
  - **Controller:** 요청 수신 → 모델 호출 → 결과를 뷰에 전달  
- **흐름:**  
  `요청 → Controller → Model 처리 → 결과 반환 → View 렌더링`
- **핵심 개념**
  - 모델과 뷰를 분리하여 유지보수 용이
  - 컨트롤러가 흐름 제어를 담당
- **장점:** 역할 분리로 구조가 명확하고 테스트, 변경 용이  
- **한계:** 규모가 커질수록 Controller와 Service가 비대해지고, 도메인 로직이 흩어지기 쉬움

---

## 2️⃣ 계층형 아키텍처 (Layered Architecture)

- **구성**
  1. **표현 계층 (Presentation Layer):** Controller, View — 요청/응답 처리
  2. **응용 계층 (Application Layer):** Service — 비즈니스 흐름 조합
  3. **도메인 계층 (Domain Layer):** 핵심 규칙, 정책 (주문 취소, 상태 전환 등)
  4. **인프라 계층 (Infrastructure Layer):** 기술 의존 (DB, 외부 연동)
- **규칙:** 상위 계층 → 하위 계층만 의존 가능
- **장점:** 구조 단순, 의존 방향이 명확, 테스트와 확장 용이  
- **단점:** 도메인 로직이 흩어지면 유지보수 어려움 → **DDD**가 이를 보완

---

## 3️⃣ DDD (Domain-Driven Design) 및 전술 패턴

- **복잡한 도메인 로직을 다루기 위한 설계 접근법**
- **핵심 구성요소**
  - Entity, Value Object, Aggregate, Repository, Domain Service, Domain Event
- **전술 패턴**
  - 도메인 간 경계를 나누는 **Bounded Context**
  - 각 컨텍스트는 독립적으로 관리되어야 하며, 이는 MSA와 잘 어울린다.
- **핵심 철학:** 기술이 아닌 **도메인 언어(Ubiquitous Language)** 중심의 개발  
- **추천 참고서:** 『도메인 주도 개발 시작하기』

---

## 4️⃣ 마이크로서비스 아키텍처 (MSA)

- **정의:** 하나의 거대한 애플리케이션을 작고 독립적인 서비스 단위로 분리하는 구조
- **도입 조건**
  1. **독립 배포:** 다른 서비스에 영향 없이 배포 가능해야 함
  2. **도메인 중심 설계:** 각 서비스는 하나의 도메인에 집중
  3. **데이터 독립:** DB 공유 금지, API로만 통신
  4. **적절한 크기:** 팀이 독립적으로 소유·운영 가능해야 함
  5. **조직 구조 반영:** 콘웨이 법칙(Conway’s Law)에 따라 조직과 아키텍처는 일치해야 함
- **장점:** 독립 배포, 유연한 확장, 기술 다양성
- **단점:** 테스트·모니터링 복잡, 배포 파이프라인 증가, 분산 트랜잭션 처리 어려움

---

## 5️⃣ 이벤트 기반 아키텍처 (Event-Driven Architecture)

- **정의:** 시스템 간 통신을 ‘이벤트(event)’ 기반으로 수행하는 구조  
  예: 주문 시스템에서 “결제 완료됨” 이벤트 → 배송 시스템 전달
- **3요소**
  1. **이벤트 생산자 (Producer):** 이벤트 생성 후 브로커로 전송
  2. **이벤트 브로커 (Broker):** 메시지를 관심 있는 소비자에게 전달 (Kafka, RabbitMQ 등)
  3. **이벤트 소비자 (Consumer):** 이벤트 수신 후 처리 로직 수행
- **장점:** 서비스 간 결합도 낮고 독립적 배포 가능
- **단점:** 이벤트 처리 순서 보장 어려움, 상태 추적 복잡
- **적합한 경우:** 시스템 간 통합, 비동기 작업, MSA 간 연동

---

## 6️⃣ CQRS (Command Query Responsibility Segregation)

- **정의:** 명령(Command: 상태 변경)과 조회(Query: 상태 조회)를 분리하는 패턴
- **배경:** 비즈니스 복잡도가 높아질수록 쓰기/읽기 모델의 데이터 구조가 달라지기 때문
- **장점**
  - 조회 전용 DB, 캐시 활용 등으로 조회 성능 극대화
  - 대규모 트래픽 분리 처리 가능 (Write DB vs Read Replica)
- **단점**
  - 모델 이중화로 코드 복잡도 증가
  - 데이터 동기화 문제 발생 가능
- **적용 예시**
  - 주문 시스템: 주문 생성(명령) DB와 주문 조회(조회) DB 분리  
  - 금융권, 이커머스 등 고성능 읽기 트래픽 처리 시스템

---

# ⚙️ ② 실무 중심 정리 — 실제 개발에서의 적용 관점

## 🧩 1. MVC vs 계층형 구조

| 항목 | MVC | 계층형 아키텍처 |
|------|------|----------------|
| 초점 | 요청–응답 흐름 | 시스템 내부 모듈 역할 분리 |
| 계층 수 | 3개 (Model/View/Controller) | 보통 4개 (Presentation/Application/Domain/Infra) |
| 스코프 | 주로 웹 프레임워크 수준 | 어플리케이션 전체 구조 |
| 실무 팁 | MVC는 Controller–Service–Repository 구조와 함께 계층형으로 결합하는 경우가 많음 |

---

## 🧩 2. DDD 적용 포인트

- 도메인 복잡도가 **비즈니스 규칙 중심**일 때 적용 가치가 높음  
- **Entity**: ID로 구분되는 객체 (주문, 회원 등)  
- **Value Object**: 불변 객체 (주소, 금액 등)  
- **Repository**: DB 접근을 도메인에서 분리  
- **Domain Event**: 다른 서비스와 비동기 통신 시 핵심 (→ Kafka, RabbitMQ 활용)
- **적용 시 주의점:** 초기 도입 비용이 높으므로, 도메인 복잡성이 높을 때만 선택

---

## 🧩 3. MSA 설계 시 실무 포인트

- **도입 기준**
  - 서비스가 자주 배포되고, 장애 전파 위험이 크거나 팀이 병렬로 일할 때
  - 모놀리식에서 성능이 아닌 **배포 독립성**이 병목이 될 때 도입
- **핵심 원칙**
  - 서비스 간 DB 공유 금지  
  - API 계약 명세(Swagger, OpenAPI)로 통신 일관성 유지  
  - 공통 모듈은 별도 라이브러리 또는 SDK로 관리
- **주의점**
  - 트랜잭션 분리 → 사가 패턴(Saga) 또는 보상 트랜잭션 필요  
  - 서비스 간 호출이 많으면 분산 모놀리식 위험

---

## 🧩 4. 이벤트 기반 구조 실무 팁

- **Kafka**는 대규모 실시간 스트림 처리에 적합 (로그, 결제 이벤트 등)
- **RabbitMQ**는 순서 보장, 소규모 트래픽, 알림 이벤트 등에 적합
- **Redis Stream / Pub-Sub**은 단순한 이벤트 브로커로 가볍게 사용 가능
- 이벤트 상태 추적을 위해 **Outbox 패턴**과 **이벤트 로그 테이블**을 병행 관리한다.
- 장애 복구 시 이벤트 재처리를 위한 **idempotent(멱등성)** 설계 필수

---

## 🧩 5. CQRS 실무 포인트

- 명령과 조회를 분리하되, 처음부터 모든 서비스에 적용하지 않는다.  
  복잡한 도메인(주문, 결제, 재고 등)에만 적용.
- 조회 모델은 ElasticSearch, Redis, Read Replica로 구성 가능.  
- 데이터 동기화는 Kafka 이벤트 또는 CDC(Change Data Capture)로 유지.

---

## 🧩 6. 아키텍처 설계의 실제 접근 순서

1. **도메인 분석** → 핵심 모델 결정  
2. **MVC or Layered 구조**로 초기 개발  
3. **도메인 복잡도 증가 시 DDD 도입**  
4. **배포·확장 요구 시 MSA 전환**  
5. **비동기 통합 필요 시 이벤트 기반 구조 추가**  
6. **조회 트래픽 폭증 시 CQRS 도입**

---

## ✅ 요약

| 패턴 | 핵심 목적 | 실무 적용 포인트 |
|------|------------|------------------|
| MVC | 표현과 비즈니스 로직 분리 | Controller 중심 흐름 제어 |
| Layered | 역할 분리, 의존 방향 명확화 | Service → Domain → Infra 구조 |
| DDD | 복잡한 도메인 관리 | Entity, Value, Event, Repository |
| MSA | 독립 배포, 확장성 확보 | 도메인 단위 서비스 분리 |
| Event-Driven | 서비스 간 결합도 최소화 | Kafka, RabbitMQ, Outbox 활용 |
| CQRS | 읽기/쓰기 분리 | 조회 캐시, ElasticSearch, Redis |

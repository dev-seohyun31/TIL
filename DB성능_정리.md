# 3장. 성능을 좌우하는 DB 설계와 쿼리

---

## 🧠 ① 개념 중심 정리 버전

### 3-1. DB는 성능의 핵심이다
- 트래픽이 늘면 **DB의 CPU 사용률이 급격히 상승** → 쿼리 실행시간 증가 → 서버 응답시간 증가.  
- 원인: **풀스캔 / 인덱스 미활용 / 쿼리 비효율 / 과도한 join / 집계 처리**  
- 서비스가 느려지는 문제 대부분은 **DB 사용 방식이 잘못된 경우**에서 비롯된다.

---

### 1️⃣ 인덱스 설계
- **조회 쿼리 패턴**과 **트래픽 규모**를 고려해야 한다.  
  - 소규모 트래픽(500건 이하)은 풀스캔도 문제 없을 수 있음.  
  - 대규모(수백만~수천만 건)는 인덱스 없으면 CPU 90% 이상 상승.  
- **복합 인덱스**: WHERE 조건 순서와 맞추어 생성.  
- **선택도(Selectivity)**: 중복이 적은 컬럼일수록 인덱스 효율 높음.  
  - 예: `user_id` ✅ / `gender` ❌  
- **커버링 인덱스**: SELECT 절의 모든 칼럼을 인덱스에 포함 → 데이터 파일 접근 불필요 → I/O 감소.  
- 인덱스는 많을수록 좋지 않다.  
  - INSERT/UPDATE/DELETE 시 인덱스 재구성 비용 발생.

---

### 2️⃣ 미리 집계하기
- COUNT, SUM 같은 집계 쿼리의 실시간 계산은 **부하가 큼**.  
- 자주 조회되는 집계값은 **비정규화된 칼럼**으로 유지 (`likedCount`, `commentCount`).  
- 단, 동시 업데이트 시 **원자성 보장 필요** → 트랜잭션 격리 수준 고려.

#### 💬 트랜잭션 격리 수준
| 수준 | 특징 | 이 경우 적합 |
|------|------|---------------|
| READ COMMITTED | 커밋된 데이터만 읽음 | 일반 서비스 (대부분 기본값) |
| REPEATABLE READ | 같은 트랜잭션 내 동일 결과 보장 | MySQL 기본, InnoDB |
| SERIALIZABLE | 완전한 순차 실행 | 동시성 낮음, 비추천 |
→ “`UPDATE ... SET answerCnt = answerCnt + 1`”처럼 단일 행 수정은 InnoDB의 **레코드 락(row lock)**으로 안전하게 원자 처리됨.

---

### 3️⃣ 페이지네이션 최적화
- `LIMIT 10 OFFSET 99990` → 앞의 99990행을 모두 스캔해야 함 → 비효율.
- 대신 `WHERE id < ? ORDER BY id DESC LIMIT 10` 형태로 “**커서 기반 페이지네이션(Cursor Pagination)**” 사용.
- 모바일 무한 스크롤 UX에도 적합.

---

### 4️⃣ 최신 데이터만 조회하기
- 데이터 양을 제한해 쿼리량 감소.  
  - 주문내역 → 최근 6개월  
  - 보안로그 → 최근 30일  
  - 구글 보안활동 → 28일  
- **비즈니스 요구와 데이터 수명 주기 정의**가 필요.

---

### 5️⃣ 전체 개수 세지 않기
- `SELECT COUNT(*)`도 **Full Index Scan** 발생 → 대규모 테이블에선 수 초 이상 지연.  
- 전체 개수는 “더보기” UX로 대체하거나, **비동기 계산 / 캐시**로 표시.

---

### 6️⃣ 오래된 데이터 삭제·분리
- 데이터가 많을수록 인덱스 트리 깊이가 커지고 쿼리 속도 저하.
- **아카이빙(Archiving)** 또는 **파티셔닝(Partitioning)**으로 관리.
- 삭제 후에도 **단편화(Fragmentation)**로 인해 실제 용량이 줄지 않을 수 있음.  
  → `OPTIMIZE TABLE`, `VACUUM`(Postgres) 등으로 재구성.

---

### 7️⃣ DB 서버 확장
- **수직 확장 (Scale-up)**: CPU/메모리/스토리지 업그레이드  
- **수평 확장 (Scale-out)**:  
  - **복제(Replication)** → 주(DB: write), 복제(DB: read) 분리.  
  - **샤딩(Sharding)** → 특정 기준으로 DB를 물리적으로 나눔 (예: user_id mod N).

---

### 8️⃣ 캐시 서버 구축
- 대규모 트래픽일수록 DB 단독 처리 불가능.  
- **Redis / Memcached**를 캐시로 두고 DB 접근 최소화.  
- DB보다 훨씬 적은 비용으로 TPS 향상 가능.  
- 단, 캐시 무효화 로직, TTL, 코드 수정 필요.

---

### ⚠️ 주의사항

| 주제 | 설명 |
|------|------|
| **쿼리 타임아웃** | 기능별로 다르게 설정. <br> - 게시글 조회: 1~3초 <br> - 결제/정산: 10초 이상 허용 |
| **복제DB 사용 주의** | 주→복제 간 지연(Replication Lag) 존재 → 변경 직후 조회는 **항상 주DB**에서 |
| **집계쿼리 모니터링** | 전체 기간 → 짧은 기간(일, 시, 분 단위)으로 쪼개서 처리 |
| **타입 불일치 조인 주의** | JOIN 칼럼의 타입, charset이 다르면 인덱스 미사용 |
| **테이블 변경 주의** | ALTER TABLE은 내부 복사 수행 → DML 중단 가능성 → 트래픽 적은 시간대에 수행 |
| **DB 커넥션 수 설정** | API서버 수 × 각 서버의 풀 크기 ≤ DB의 `max_connections` |
| **트랜잭션 사용 주의** | 외부 API 호출과 DB작업을 한 트랜잭션에 묶지 않기. <br> 실패 시 롤백 폭이 커짐. |

---

## ⚙️ ② 실무 중심 튜닝 포인트 정리

| 구분 | 실무 포인트 | 체크 기준 / Best Practice |
|------|--------------|----------------------------|
| **인덱스** | - WHERE, JOIN, ORDER BY에 사용되는 칼럼만 인덱스 생성<br>- 선택도 높은 컬럼 우선 | `EXPLAIN`으로 index scan 확인 |
| **커버링 인덱스** | SELECT 절에 포함된 칼럼이 인덱스에 모두 있을 때 활용 | Extra: “Using index” |
| **비정규화 집계칼럼** | count/sum 실시간 쿼리 → `update set col = col + 1` | 트랜잭션 락 확인 (InnoDB row-level lock) |
| **페이지네이션** | OFFSET 대신 Cursor 방식 (`WHERE id < ?`) | p95 latency 50% 이상 단축 |
| **데이터 수명관리** | 오래된 로그 180일 이상 자동 삭제 | Cron + Archive Table |
| **COUNT(*) 최적화** | Redis에 count 캐싱 / background job으로 계산 | API는 async 응답 |
| **아카이빙** | 월별 테이블 분할 or Partition Table | 최근 테이블만 실시간 사용 |
| **복제 DB 활용** | 주DB: write / 복제DB: read | replication lag < 1s 유지 |
| **캐시 도입** | 조회용 데이터 Redis 캐싱 | hit ratio 80%↑ 유지 |
| **쿼리 타임아웃** | 기능별 timeout 차등 적용 | 일반 조회 3s, 결제 10s |
| **타입 일치 조인** | varchar ↔ int 혼용 금지 | Schema 검사, CAST 명시적 지정 |
| **ALTER TABLE** | 배포 전/비업무 시간대 수행 | Online DDL(Percona 등) 활용 |
| **DB 커넥션 관리** | 서버 수 × pool size ≤ max_connections | CPU 여유 시 확장 |
| **트랜잭션 분리** | 외부 API + DB 작업 분리 트랜잭션 | 회원가입/메일발송 등 분리 |

---

## 💬 보충 설명

| 질문 | 답변 |
|------|------|
| ❓ “어떤 격리수준이어야 해?” | MySQL InnoDB 기본인 `REPEATABLE READ`는 `UPDATE answerCnt = answerCnt + 1` 형태의 단일행 업데이트 시 충돌 없이 안전함. 단, 동시성이 매우 높다면 optimistic locking 고려. |
| ❓ “삭제 후에도 용량이 안 줄어드는 이유?” | 삭제 시 디스크 공간이 바로 해제되지 않고 남아있음. `OPTIMIZE TABLE`로 재구성해야 실제 용량 회수됨. |
| ❓ “DB 연결 갯수 늘리면 해결돼?” | CPU 사용률이 20~50% 정도 여유 있을 때만 유효. CPU가 이미 70% 이상이면 오히려 지연만 증가. |
| ❓ “복제DB 언제 쓰면 안돼?” | 동일 요청 내에서 `UPDATE → SELECT` 하는 경우, 복제DB는 아직 변경 반영 전일 수 있음. 반드시 주DB에서 조회. |
| ❓ “트랜잭션 중간 오류 시 커밋해야 하는 경우?” | 비즈니스 핵심 로직(회원가입 등)은 커밋 후 별도의 보조 프로세스(메일, 로그 등)로 분리해야 함. |

---

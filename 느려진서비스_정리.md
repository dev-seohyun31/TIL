# 2장. 느려진 서비스 정리

---

## 🧠 ① 개념 정리 중심 버전

### 2-1. 처리량과 응답시간

#### ✅ 응답시간(Response Time)
- 사용자의 요청이 완료되어 응답이 돌아오기까지의 전체 시간.  
  구성: **(서버 연결 + 데이터 전송 + 서버 처리 + 응답 전송)**  
- 서버 처리 구간은 다음 4가지 요소로 세분화됨:
  1. 로직 수행  
  2. DB 연동 (가장 큰 비중)  
  3. 외부 API 연동 (두 번째 큰 비중)  
  4. 응답 데이터 생성 및 전송  
- **측정 지표**
  - **TTFB**(Time To First Byte): 첫 바이트가 도착하기까지  
  - **TTLB**(Time To Last Byte): 마지막 바이트까지 도착  
- 단위는 ms(밀리초).  
- 응답시간 ↑ ⇒ 사용자 만족도 ↓, 매출 ↓  
  (Google: 100ms 지연 시 매출 1% 감소)

#### ✅ 처리량(Throughput)
- **단위 시간당 처리 가능한 요청 수**  
  - **TPS**: 초당 완전히 처리된 트랜잭션 수  
  - **RPS**: 초당 요청(Request) 수  
- 최대 TPS 초과 시 → 대기 큐가 생기고, 응답시간 급증.  
- 개선 방향
  1. **최대 TPS를 높인다.** (시스템 용량 확장)
  2. **처리시간을 줄인다.** (병목 최적화)

#### ✅ 성능 측정 3단계
1. 트래픽이 많은 시간대의 TPS / 응답시간 측정  
2. 목표치 설정  
3. 원인 분석 및 개선

---

### 2-2. 서버 성능 개선 기초

#### ✅ 성능 저하의 징후
- 응답이 전체적으로 느려짐 (10초 이상)
- 서버 재시작 시 일시적 회복
- 트래픽이 줄면 다시 정상화  
👉 원인: **최대 TPS 초과**

#### ✅ 성능 개선 접근
1. **병목 지점 파악**
   - 처리 시간이 긴 부분 (DB, 외부 API)
2. **수직 확장(Scale Up)**
   - CPU, Memory, Disk 성능 업그레이드  
   - 예: DB 서버를 SSD로 교체  
   - *메모리 증설이 동시 요청 처리에 효과적인 이유*:  
     스레드, 커넥션, 버퍼가 동시에 메모리를 점유하므로, 여유 메모리가 늘면 동시처리량이 증가함.
3. **수평 확장(Scale Out)**
   - 서버 수를 늘려 부하 분산  
   - 단, DB나 외부 API가 병목이면 효과 없음

---

### 2-3. DB 커넥션 풀

#### ✅ 필요성
- DB 연결·종료가 매우 비싼 연산  
- 매 요청마다 연결/종료 시 처리량 급감  
- → 미리 연결을 확보해두는 **커넥션 풀(Connection Pool)** 필수

#### ✅ 동작 개념
- 서버가 시작될 때 **DB 연결 객체(Connection)** 여러 개를 만들어 **풀(Pool)** 에 보관  
- 요청이 들어올 때 → **빈 커넥션을 할당** → 사용 후 **반납**  
- 예시: `javax.sql.DataSource` 인터페이스 기반 구현  
  - Spring Boot 기본: **HikariCP**
  - Java 표준: `DriverManager` 직접 연결 가능하지만 비효율적

#### ✅ 주요 설정
1. **풀 크기**
   - 동시에 사용할 수 있는 커넥션 수
   - 초과 시 대기 큐(BlockingQueue)에서 대기
2. **대기 시간**
   - 커넥션이 없을 때 기다릴 최대 시간 (`connectionTimeout`)
   - 초과 시 `DBConnectionFailException`
   - Hikari 기본값: 30초 (실무: 0.5~3초 권장)
3. **유휴/유지 시간**
   - DB가 커넥션을 일정 시간 후 끊을 수 있으므로,
     - **maxIdleTime**(최대 유휴시간)
     - **maxLifetime**(최대 유지시간)
     - **validationQuery**(유효성 검사 쿼리, 예: `SELECT 1`)
   - DB의 커넥션 타임아웃보다 **짧게 설정**

---

### 2-4. 서버 캐시

#### ✅ 캐시의 기본
- 자주 조회되는 데이터를 **메모리 기반 Key-Value 저장소**에 저장하여 DB 부하를 줄임
- 효율성 지표: **캐시 적중률 = 캐시에서 조회 성공 건수 / 전체 조회 시도 수**

#### ✅ 캐시의 종류
| 구분 | 특징 | 예시 | 사용 시점 |
|------|------|------|-----------|
| 로컬 캐시 | 애플리케이션 메모리 내 저장, 속도 빠름, 서버 재시작 시 사라짐 | Caffeine, Guava, go-cache | 데이터 크기 작고 변경 적음 |
| 리모트 캐시 | 별도 서버 (Redis, Memcached), 수평확장 가능, 네트워크 오버헤드 존재 | Redis | 대규모 트래픽, 변경 빈도 높음 |

#### ✅ 캐시 정책
- **TTL(Time To Live)**: 만료시간 설정
- **Eviction Policy**: LRU, LFU, FIFO
- **Preloading**: 트래픽 급증 전 캐시 미리 적재
- **Invalidation**: 데이터 변경 시 캐시 무효화

---

### 2-5. 응답 데이터 압축
- 텍스트 응답(JSON, HTML 등)은 **gzip 압축**으로 70% 이상 절감 가능  
- 단, 방화벽·Proxy가 압축 허용해야 함

---

### 2-6. 정적 자원 처리
- JS, CSS, 이미지 → 클라이언트 캐시(`Cache-Control: max-age`)
- 글로벌 서비스 → CDN(Content Delivery Network) 활용

---

### 2-7. 대기 처리
- 서버와 DB 증설이 어려운 경우, **비동기 대기 시스템**(Queue) 도입  
  → 메시지 큐, Kafka, RabbitMQ 등으로 비동기 처리

---

## ⚙️ ② 실무 중심 요약 및 튜닝 포인트

| 구분 | 실무 포인트 | 체크/튜닝 기준 |
|------|-------------|----------------|
| **응답시간** | APM(New Relic, Pinpoint, Scouter)로 API별 평균·P95 응답시간 추적 | <150ms(요청 종류별 다름) |
| **처리량(TPS)** | 부하테스트(k6, JMeter)로 최대 처리량 측정 | 초당 트랜잭션 수(TPS) 기준 10~20% 여유 |
| **DB Connection Pool** | Hikari 설정: `maximumPoolSize`, `connectionTimeout`, `idleTimeout`, `maxLifetime` | DB CPU 사용률 70% 미만 유지 |
| **로컬 캐시** | Caffeine 사용, TTL 10분 내외, 용량 제한 | hit ratio 80% 이상 |
| **리모트 캐시** | Redis, key 규칙화(`entityType:id`), TTL/Invalidation 설정 | key TTL = 실제 데이터 갱신 주기 |
| **압축/전송 최적화** | gzip or Brotli 적용, JSON 최소화 | 응답 크기 50~70% 감소 |
| **정적 자원** | CDN + 브라우저 캐시 활용 | 요청 수 감소, TTFB 개선 |
| **Scale Out 시 주의** | DB 병목 해결 전 서버만 늘리면 역효과 | RDS CPU 70% 이상일 때만 scale out |
| **가비지 컬렉션** | Full GC로 인한 지연 주기 모니터링 | GC 시간 100ms 이상이면 튜닝 |
| **대기 처리(비동기)** | 메시지 큐(Kafka, RabbitMQ)로 지연 작업 분리 | API 응답시간 단축 |

---

## 💬 보충 설명

| 질문 | 답변 |
|------|------|
| “항상 연결되어 있다면 자원이 계속 소비되는 거네?” | 네. Connection Pool의 커넥션은 실제로 DB와 TCP 연결을 유지하므로 메모리·소켓 자원을 점유합니다. 다만, 계속 재활용하기 때문에 매번 연결/해제하는 것보다 훨씬 효율적입니다. |
| “자바로 치면 어떤 클래스고 디비 쪽은 뭐지?” | 서버 쪽은 `javax.sql.DataSource` 인터페이스 구현체(HikariDataSource 등), DB는 실제 DBMS 프로세스(MySQL, Oracle 등)에서 연결 세션(Session)을 의미합니다. |
| “어디서 대기?” | 풀에 여유 커넥션이 없으면 `BlockingQueue`에 들어가 대기합니다. Hikari는 내부적으로 SynchronousQueue로 요청을 대기시킵니다. |
| “대기 요청이 쌓인다(어디에?)” | 서버 스레드풀(예: Tomcat thread pool) 또는 커넥션풀의 대기큐에 쌓입니다. 일정 시간 초과 시 `TimeoutException`. |
| “메모리 증설로 동시요청이 늘어나는 이유?” | 각 요청은 스레드·버퍼·세션을 생성하므로 RAM 여유가 늘면 더 많은 요청을 동시에 처리할 수 있습니다. |

---

## 📘 Read Timeout vs Connection Timeout

| 구분 | 정의 | 발생 시점 | 예시 |
|------|------|-----------|------|
| **Connection Timeout** | 서버와 **연결을 맺는 데까지 걸리는 시간** 제한 | 요청 전 | 서버가 다운되었거나 포트가 열리지 않았을 때 |
| **Read Timeout** | 서버와 연결된 뒤, **응답 데이터를 받는 데 걸리는 시간** 제한 | 요청 후 | 서버 로직이 너무 오래 걸려 응답을 못 주는 경우 |

- 예를 들어, 클라이언트가 서버로 요청을 보낼 때:
  1. **Connection Timeout**: “연결 자체가 안 돼요.” (네트워크/서버 다운)
  2. **Read Timeout**: “연결은 됐는데, 응답이 안 와요.” (DB 지연, 로직 문제)

---

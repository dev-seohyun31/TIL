# 7장. IO 병목, 어떻게 해결하지

---

## 7-1. 서버와 IO의 관계

- 서버 프로그램은 본질적으로 **네트워크 기반 IO 프로그램**이다.  
  - 예: HTTP 요청/응답, TCP로 DB와 통신 등.  
- 개발자가 직접 소켓을 다루지 않아도, 모든 요청은 **OutputStream / InputStream**으로 데이터를 주고받는다.
- 예시:  
  서버가 DB에 쿼리를 보낼 때 → “SELECT …” 전송(출력 스트림) → DB 응답 수신(입력 스트림)
- IO 동안 스레드는 **대기 상태(Blocking)** 에 머문다.
- 대부분의 서비스 병목은 CPU가 아닌 **IO 대기 시간**에서 발생한다.

---

## 7-2. 톰캣 요청 처리 구조와 자원 낭비

- 톰캣은 요청마다 스레드를 생성해 처리한다.
- 트래픽 증가 시 비효율 발생 이유:
  1. **IO 대기 + 컨텍스트 스위칭**으로 CPU 낭비.
  2. **스레드별 메모리 사용량** 증가.
- 초기엔 CPU/메모리보다 **DB·외부 연동**이 주된 병목이다.
- 트래픽이 많아질수록 IO 구조 최적화 필요.

---

## 7-3. 자원 효율을 높이는 방법

### 1️⃣ 경량 스레드 사용 (가상 스레드, 고루틴)

- OS가 아닌 **JVM이 관리하는 스레드**.  
  플랫폼 스레드 위에서 JVM이 여러 가상 스레드를 번갈아 실행.
- **장점**
  - 메모리 사용량이 적고, 생성 속도 빠름.
  - IO 중심 서비스에 적합.
- **동작**
  - 가상 스레드가 블로킹되면 플랫폼 스레드에서 분리(언마운트).  
    플랫폼 스레드는 다른 가상 스레드를 실행해 CPU 효율 극대화.
- **주의점**
  - CPU 중심 작업(이미지 처리 등)에는 효과 없음.
  - 가상 스레드 수 > 플랫폼 스레드 수 여야 이점이 있다.
- 예: CPU 16코어 서버, IO 중심 요청 TPS 500 → 가상 스레드 10개면 충분.

> 💡 가상 스레드는 **동시 처리량을 늘리는 기술**이지, **처리 속도를 높이는 기술은 아니다.**

---

### 2️⃣ 논블로킹 / 비동기 IO

- IO 요청 후 스레드가 **대기하지 않고 바로 리턴**.  
  → 입출력 완료 시 이벤트 루프(리액터)가 콜백을 호출.
- **장점**
  - 스레드 수 적게 유지 (수천 요청을 몇 스레드로 처리)
  - CPU 낭비 최소화
- **예시 프레임워크**
  - Netty, Nginx, Node.js, Spring WebFlux(Reactor 기반)
- **패턴**
  - Reactor(이벤트 루프): IO 이벤트 감지 → 핸들러 호출 → 처리.

> 💬 블로킹 IO: 요청 1개당 스레드 1개 필요  
> 💬 논블로킹 IO: 요청 수와 관계없이 소수 스레드로 처리

---

## 7-4. 언제 어떤 방법을 쓸까

| 판단 단계 | 점검 내용 | 권장 대응 |
|------------|-----------|------------|
| ① 성능 문제가 있는가 | 트래픽, 응답시간 분석 | 문제 없으면 기존 구조 유지 |
| ② 병목 원인이 IO인가 | DB 쿼리, CPU 사용량, 외부 API 점검 | IO 병목일 때만 구조 개선 |
| ③ 구조 변경이 가능한가 | 리소스·인력 고려 | 불가능하면 서버 확장으로 대응 |

---

## 7-5. 핵심 요약

| 항목 | 설명 | 비고 |
|------|------|------|
| **가상 스레드** | JVM 관리 스레드로 메모리 효율적 | IO 중심 작업에 효과적 |
| **논블로킹 IO** | 스레드 대기 없이 이벤트 기반 처리 | Reactor, Netty, WebFlux 등 |
| **비동기 IO** | 논블로킹 IO + 콜백 구조 | 고성능 서버에 적합 |
| **적용 시점** | 트래픽 급증, IO 대기 과다 | 일반 서비스엔 과도 |
| **부적합 사례** | CPU 중심 작업 | 오히려 성능 저하 가능 |

---

## 💡 결론

- **IO 병목은 대부분 스레드의 대기에서 발생**한다.  
- 해결책은 두 가지다:  
  1️⃣ 스레드 효율을 높인다 (가상 스레드)  
  2️⃣ IO 자체 구조를 바꾼다 (논블로킹 IO)  
- 초기 서비스는 단순 확장으로도 충분하지만,  
  트래픽이 폭증하면 **가상 스레드 → 논블로킹 IO → Reactor 구조**로 진화해야 한다.

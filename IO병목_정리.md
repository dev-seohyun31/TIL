# 📘 실무형 서버 성능 개선 가이드 (1~7장 종합 정리)

---

## **1장. 성능은 어디서 병목이 생기는가**

- 대부분의 성능 문제는 **서버 코드보다는 데이터베이스(DB)나 외부 연동 구간**에서 발생한다.  
- 클라이언트 요청이 늘어날수록 DB CPU 사용률이 90% 이상으로 치솟는 경우가 많으며, 이는 대부분 **쿼리 실행 시간이 길어졌기 때문**이다.  
- 따라서 서비스 전체 성능을 높이기 위해서는 코드보다 **DB 구조와 쿼리 효율**이 핵심이다.  
- 성능은 시스템 전체의 병목을 기준으로 분석해야 하며, **서버 → DB → 외부 연동 → 네트워크 순으로 점검**한다.

---

## **2장. 서버의 응답시간을 줄이기 위한 기본기**

- 응답시간(Response Time)을 단축시키려면 다음 3가지를 고려해야 한다.
  1. **처리량(Throughput)**: 초당 처리 가능한 요청 수를 높인다.
  2. **대기시간(Waiting Time)**: 요청이 서버 리소스(스레드, 커넥션)를 기다리는 시간을 최소화한다.
  3. **병렬성(Concurrency)**: 요청을 동시에 처리할 수 있는 스레드, 커넥션 수를 적정 수준으로 유지한다.
- 응답시간은 코드 실행 속도보다 **대기와 I/O의 효율성**에 더 영향을 받는다.
- 불필요한 DB 호출, 외부 API 호출, 파일 입출력, 동기화 코드 등은 **즉시성(Real-time)** 요구가 없는 이상 **비동기화로 전환**한다.

---

## **3장. 성능을 좌우하는 DB 설계와 쿼리**

### 1️⃣ 인덱스 설계
- 조회 패턴을 기준으로 인덱스를 설계한다.  
- **복합 인덱스**도 조회 조건의 순서와 패턴에 맞게 생성한다.  
- 인덱스는 많을수록 좋지 않다. (변경 비용 발생)
- **커버링 인덱스**: 쿼리에 필요한 모든 칼럼을 포함하는 인덱스.
- **선택도(Selectivity)**: 고유값이 많을수록 인덱스 효율이 높다.

### 2️⃣ 미리 집계하기
- 실시간 `COUNT(*)`보다 **집계 칼럼을 추가**해 관리한다.  
  - 예: `likedCount`, `answerCnt` 등.
- 불일치를 감수하더라도 비정규화로 속도를 확보한다.

### 3️⃣ 페이지네이션 최적화
- `LIMIT 10 OFFSET 99990`은 비효율적이다.  
- **Keyset Pagination** 사용:  
  `WHERE id < :lastId ORDER BY id DESC LIMIT 10`

### 4️⃣ 조회 데이터 범위 제한
- “최근 3개월”, “최근 100건” 등 **업무적 범위를 제한**한다.

### 5️⃣ 전체 개수 카운트 생략
- `COUNT(*)`는 인덱스 풀스캔이 발생하므로, 전체 개수 표시를 생략할 수 있다.

### 6️⃣ 데이터 삭제 및 분리 보관
- 오래된 데이터는 별도 테이블 또는 저장소로 분리.

### 7️⃣ DB 확장
- **수직 확장(Scale Up)**: CPU·RAM 증설.
- **수평 확장(Scale Out)**: 주DB-복제DB 구조로 조회 분리.

### 8️⃣ 캐시 서버
- Redis 등 캐시로 트래픽을 흡수.

---

## **4장. 외부 연동이 문제일 때**

### 1️⃣ 타임아웃 설정
- 연결과 응답을 분리:
  - **Connection Timeout**: 연결 시도 단계 (3~5초)
  - **Read Timeout**: 응답 수신 단계 (5~30초)

### 2️⃣ 재시도 전략
- 단순 조회나 멱등한 변경 요청만 재시도.  
- 재시도 횟수는 1~2회, 간격은 점진적으로 늘린다.

### 3️⃣ 서킷 브레이커
- 외부 오류가 연속되면 호출을 중단.  
  - 상태: **닫힘 → 반열림 → 열림**

### 4️⃣ 외부 연동 트랜잭션 처리
- 외부 연동 실패 시 보상 트랜잭션 설계 필요.  
- DB 트랜잭션 중 외부 API 호출 금지.

---

## **5장. 비동기 연동 — 언제, 어떻게 써야 하는가**

### 비동기 필요성
- 외부 연동이 실패해도 전체 서비스는 동작해야 한다.
- 응답 지연을 줄이고, 불필요한 대기시간을 제거한다.

### 구현 방식
1️⃣ **별도 스레드 실행** (`@Async`)  
2️⃣ **메시징 시스템 사용** (Kafka, RabbitMQ 등)  
3️⃣ **트랜잭션 아웃박스 패턴**  
4️⃣ **배치 연동**  
5️⃣ **CDC(Change Data Capture)**  

---

## **6장. 동시성 — 데이터가 꼬이기 전에 잡아야 한다**

### 1️⃣ 단일 프로세스 내 제어
- **Lock:** 한 번에 한 스레드만 접근 (`ReentrantLock`)
- **Semaphore:** N개 스레드만 접근 허용
- **ReadWriteLock:** 읽기 다중 허용, 쓰기 단독
- **Atomic:** CAS 연산으로 잠금 없이 원자적 처리
- **Concurrent 컬렉션:** 잠금 최소화
- **Single-thread Queue:** 큐에 담고 단일 스레드로 처리

### 2️⃣ DB 내 제어
- **비관적 잠금:** `SELECT ... FOR UPDATE`
- **낙관적 잠금:** `version` 비교로 충돌 감지
- **원자 연산:** `UPDATE ... SET count = count + 1`

### 3️⃣ 분산 환경 제어
- **Redis SETNX**, **ZooKeeper**, **DB Lock Table** 사용

### 4️⃣ 잠금 사용 시 주의사항
- `finally`에서 해제 필수  
- `tryLock(timeout)`으로 대기 제한  
- 락 순서 통일, 교착상태 방지

---

## **7장. IO 병목, 어떻게 해결하지**

### 7-1. 서버와 IO의 관계
- 서버는 본질적으로 **네트워크 기반 IO 프로그램**이다.
- 모든 요청은 **OutputStream / InputStream**을 통해 통신한다.
- IO는 CPU 연산보다 느리며, **IO 대기시간이 길어질수록 CPU는 낭비**된다.

### 7-2. 톰캣 요청 처리 구조와 자원 낭비
- 톰캣은 요청마다 스레드를 생성.  
  트래픽이 많을 때 비효율 발생:
  1. IO 대기로 인한 CPU 낭비  
  2. 스레드당 메모리 사용 증가  
- 대부분 서비스는 초기엔 이 문제보다 DB나 외부 API가 병목이다.  
- 트래픽 급증 시 **수평/수직 확장** 또는 **IO 구조 개선** 고려.

---

### 7-3. 자원 효율을 높이는 방법

#### 1️⃣ 경량 스레드 사용 (가상 스레드, 고루틴)
- JVM이 직접 관리하는 스레드 → **OS 스레드보다 메모리 사용량↓**
- `Thread.ofVirtual()`로 가볍게 생성 가능.
- **IO 중심 서비스에 적합**, CPU 중심 작업에는 부적합.
- 가상 스레드 수가 플랫폼 스레드보다 많아야 효과적.

#### 2️⃣ 논블로킹 / 비동기 IO
- IO 대기 없이 **즉시 반환**하는 구조.  
- Reactor 패턴 기반 (이벤트 루프, 핸들러 호출).
- **Nginx, Netty, Node.js, Spring WebFlux** 등이 대표적.
- 소수의 스레드로 수천~수만 요청 처리 가능.

---

### 7-4. 선택 기준

| 판단 단계 | 점검 내용 | 권장 대응 |
|------------|-----------|------------|
| ① 성능 문제가 있는가 | 트래픽, 응답시간 분석 | 문제 없으면 유지 |
| ② 병목 원인이 IO인가 | DB/CPU/네트워크 점검 | DB면 쿼리 최적화 |
| ③ 구조 변경 가능한가 | 개발 리소스 확인 | 불가능하면 확장 고려 |

---

### 7-5. 핵심 요약

| 항목 | 설명 | 비고 |
|------|------|------|
| **가상 스레드** | JVM 관리 스레드로 메모리 효율적 | IO 중심 작업에 효과적 |
| **논블로킹 IO** | 스레드 대기 없이 이벤트 기반 처리 | Reactor, Netty 등 |
| **비동기 IO** | 논블로킹 IO + 콜백 구조 | 고성능 서버에 적합 |
| **적용 시점** | 트래픽 급증, IO 대기 과다 | 일반 서비스엔 과도 |
| **부적합 사례** | CPU 중심 작업 | 오히려 성능 저하 |

---

## ✅ 전체 요약

| 장 | 핵심 키워드 | 실무 포인트 |
|----|--------------|--------------|
| 1장 | 병목 식별 | 대부분 DB·외부 연동에서 발생 |
| 2장 | 응답시간 단축 | 비동기화, 병렬성 확보 |
| 3장 | DB 성능 | 인덱스, 비정규화, 캐시 |
| 4장 | 외부 연동 | 타임아웃, 재시도, 서킷브레이커 |
| 5장 | 비동기 처리 | 메시징, Outbox, CDC |
| 6장 | 동시성 | Lock, Atomic, 분산락 |
| 7장 | IO 병목 | 가상 스레드, 논블로킹 IO |

---

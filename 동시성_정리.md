# 6장. 동시성 — 데이터가 꼬이기 전에 잡아야 한다

---

## 🧠 ① 개념 중심 정리 버전

### 6-1. 동시성의 필요성과 위험성
- 서버는 여러 클라이언트의 요청을 동시에 처리해야 한다.  
  순차 처리 시 처리량과 응답시간이 급격히 저하된다.  
  예: 100개 요청 × 0.1초 = 총 10초 → TPS(초당 처리수) 감소.
- **하지만 동시성 = 위험성**  
  동시에 같은 데이터를 수정하면 **데이터 불일치/정합성 깨짐** 발생.
- 대부분의 동시성 오류는 바로 드러나지 않고, 일정한 부하나 타이밍에서 “간헐적으로” 발생한다.

---

## 6-2. 단일 프로세스 내 동시 접근 제어

### 1️⃣ Lock (잠금)
- **한 시점에 한 스레드만 공유 자원 접근 가능**
- 흐름: 잠금 획득 → 임계영역 실행 → 잠금 해제  
- Java 예시:
  ```java
  ReentrantLock lock = new ReentrantLock();
  lock.lock();
  try {
      count++;
  } finally {
      lock.unlock();
  }
  ```

---

### 2️⃣ Semaphore (세마포어)
- **동시에 접근 가능한 스레드 수를 제한**하는 기법.  
  Lock이 “1개 스레드 전용”이라면, **Semaphore는 N개 허용 버전**.
- 예:
  ```java
  Semaphore sem = new Semaphore(3); // 3개의 스레드까지 동시 실행 허용
  sem.acquire();
  try { ... } finally { sem.release(); }
  ```
- 🔍 차이점  
  | 구분 | Lock | Semaphore |
  |------|------|------------|
  | 허용 스레드 수 | 1개 | 여러 개 |
  | 용도 | 공유 자원 보호 | 동시 실행 제한 |
  | 구현 원리 | 뮤텍스 | 퍼밋(permit) 기반 |

---

### 3️⃣ ReadWriteLock (읽기-쓰기 잠금)
- **읽기 동시 허용, 쓰기 단독 허용**
- 읽기 잠금이 활성화되면 쓰기 잠금 대기.  
  반대로 쓰기 잠금 중에는 읽기 접근 불가.
- 예:
  ```java
  ReadWriteLock rw = new ReentrantReadWriteLock();
  rw.readLock().lock();
  rw.readLock().unlock();
  ```

---

### 4️⃣ 원자적 타입 (Atomic)
- **CAS(Compare-And-Swap)** 연산을 이용해 잠금 없이 동시성 해결.  
  즉, “현재 값이 내가 본 값과 같으면 교체” 방식.
- 예:
  ```java
  AtomicInteger count = new AtomicInteger();
  count.incrementAndGet();  // 내부적으로 CAS 수행
  ```
- 장점: 블로킹 없이 빠름 (CPU 효율↑).  
- 단점: 복잡한 연산(2단계 이상)은 적용 어렵다.

---

### 5️⃣ 동시성 지원 컬렉션
- 기존 컬렉션(`HashMap`, `ArrayList`)은 스레드 안전하지 않음.  
- **대안:**
  - `ConcurrentHashMap`
  - `CopyOnWriteArrayList`
  - `ConcurrentLinkedQueue`
- 특징: 잠금 범위를 최소화하여 높은 처리량 유지.

---

### 6️⃣ 단일 스레드 접근 모델 (큐 기반)
- 여러 요청을 **작업 큐(Work Queue)**에 넣고 **단일 스레드가 순차 실행**.  
  → 잠금 불필요, 코드 단순.
- 예:
  - `Executors.newSingleThreadExecutor()`
  - 이벤트 루프 기반(`Netty`, `Node.js`, `Vert.x`)
- 단점: 구조 복잡, 처리 병목 가능.
- 장점: 비동기/논블로킹 IO 환경에 매우 적합.

---

## 6-3. DB에서의 동시 접근 제어

### 1️⃣ 비관적 잠금 (Pessimistic Lock)
- **“먼저 잡은 사람이 이김”**  
- 동일 레코드에 하나의 트랜잭션만 접근 가능.
- SQL 예:
  ```sql
  SELECT * FROM orders WHERE id = 1 FOR UPDATE;
  ```
- 다른 트랜잭션은 해당 트랜잭션 종료 전까지 대기.
- 특징:
  - 충돌 가능성 높을 때 유용.
  - 외부 연동(예: PG사 결제취소) 등 **트랜잭션이 길어질 때 필수**.

---

### 2️⃣ 낙관적 잠금 (Optimistic Lock)
- 직접 잠그지 않고, **버전(version)** 필드 비교로 충돌 감지.
- SQL 예:
  ```sql
  SELECT id, version FROM orders WHERE id = 1;
  UPDATE orders SET amount=?, version=version+1 WHERE id=1 AND version=?;
  ```
- `update count == 0` → 충돌 발생 → 재시도 or 롤백.
- 장점:
  - 잠금 대기시간 없음 → 빠른 처리
  - 읽기 많은 환경에 유리
- 단점:
  - 충돌 시 재시도 로직 필요

---

### 3️⃣ 원자적 증가 (Atomic Increment)
- SQL 수준에서의 CAS:
  ```sql
  UPDATE user_point SET point = point + 1 WHERE user_id = ?;
  ```
- 별도의 Lock 없이 안전한 원자 연산.

---

## 6-4. 여러 프로세스(분산 환경)에서의 동시 접근 제어

### 🔒 분산 잠금 (Distributed Lock)
- 여러 서버/프로세스가 하나의 자원을 동시에 수정할 때 필요.
- 구현 방식:
  - **DB 기반 잠금 테이블**
  - **Redis 기반 락 (SETNX)**
  - **ZooKeeper 기반 락**
- DB 예시 테이블:
  ```
  dist_lock(name PK, owner, expiry)
  ```
- 흐름:
  1. 트랜잭션 시작  
  2. `SELECT ... FOR UPDATE` 로 락 시도  
  3. 락 없으면 insert  
  4. 만료(expiry) 지났으면 owner 갱신  
  5. 성공 시 커밋  
  6. 실패 시 대기 or 반환  

- Java 인터페이스 예:
  ```java
  public interface DistLock {
      boolean tryLock(String name, String owner, Duration timeout);
      void release(String name, String owner);
  }
  ```

---

## 6-5. 잠금 사용 시 주의사항
| 항목 | 설명 |
|------|------|
| **해제 필수** | finally 블록에서 `unlock()` 수행 |
| **대기시간 설정** | `tryLock(timeout)` 사용 |
| **교착상태 방지** | 락 순서 일관성 유지 |
| **모니터링** | 락 획득 실패율, 대기시간 관찰 |
| **스레드 중단 대응** | interrupt 발생 시 빠른 종료 처리 |

---

## ⚙️ ② 실무 중심 정리 버전

| 항목 | 실무 포인트 | 예시/설명 |
|------|--------------|------------|
| **Lock** | 단일 스레드 보호 | `ReentrantLock`, `synchronized` |
| **Semaphore** | N개 스레드 동시 접근 제한 | API rate-limit, 연결 풀 제어 |
| **ReadWriteLock** | 읽기 성능 향상 | 다중 읽기-단일 쓰기 |
| **Atomic 계열** | 고성능 비블로킹 연산 | `AtomicInteger`, `CAS` |
| **Concurrent 컬렉션** | 멀티스레드 안전한 자료구조 | `ConcurrentHashMap` |
| **Single-thread Queue** | 이벤트 기반 처리 | Netty, Kafka Consumer |
| **비관적 잠금** | 강력한 트랜잭션 보호 | `SELECT ... FOR UPDATE` |
| **낙관적 잠금** | 재시도 로직 필요 | `version` 필드 비교 |
| **원자적 연산** | DB-level CAS | `UPDATE ... SET count=count+1` |
| **분산 락** | 여러 서버에서의 충돌 방지 | Redis `SETNX`, DB `FOR UPDATE` |
| **락 해제 보장** | `finally { unlock(); }` | 예외 발생 시에도 반드시 해제 |
| **락 타임아웃** | 대기시간 제한 | `tryLock(5, TimeUnit.SECONDS)` |
| **교착상태 방지** | 락 순서 일관성 유지 | 동일 자원 락 획득 순서 통일 |

---

## 💬 보충 설명 (물음표 해설)

| 질문 | 답변 |
|------|------|
| “세마포어는 락과 뭐가 달라요?” | Lock은 1개 스레드만, Semaphore는 여러 스레드가 동시에 접근할 수 있도록 **퍼밋 수**를 지정. 즉, “한 개냐 여러 개냐”의 차이이지만 개념적으로는 **동시 접근 제한 vs 단일 접근 보장**으로 구분됨. |
| “CAS 연산이 뭐예요?” | Compare-And-Swap. CPU 명령어 수준에서 “현재 메모리 값이 기대값과 같다면 교체”를 수행. 실패 시 다시 시도. 대기(lock)가 없어 빠름. |
| “분산락은 자바 코드로 짜요? 인프라로 해요?” | 둘 다 가능. 보통 Redis 기반(SETNX + TTL)으로 구현하거나 Redisson 라이브러리 사용. DB 기반은 단순하지만 성능 낮음. |
| “교착상태(Deadlock) 방지는 어떻게?” | 항상 같은 순서로 락 획득, 타임아웃 설정(`tryLock`)으로 강제 해제. |
| “락을 놓치면?” | 반드시 `finally`에서 해제하거나 try-with-resources 패턴 사용. |

---

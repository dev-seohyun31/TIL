# 실제 개념
## ISA란
명령어 집합 구조(ISA, Instruction Set Architecture)란, CPU가 명령어를 어떻게 이해하고 어떤 규칙으로 실행하는지를 정의한 설계 규칙입니다.
ISA 설계 철학은 크게 두 가지로 나뉩니다.
* CISC (Complex Instruction Set Computer)
  → 복잡하고 강력한 명령어 하나로 여러 단계를 한 번에 수행하는 방식
  * `MULT 2:3, 5:2` : 메모리 (2,3) 위치에 있는 값과 (5,2) 위치에 있는 값을 직접 곱해서 그 결과를 다시 메모리에 저장해라.
* RISC (Reduced Instruction Set Computer)
  → 단순한 명령어를 매우 빠르게, 반복 실행해 전체 성능을 높이는 방식
  * `LOAD R1, 2:3` : 메모리 (2,3)의 값을 레지스터 1로 가져와라.
  * `LOAD R2, 5:2` : 메모리 (5,2)의 값을 레지스터 2로 가져와라.
  * `PROD R1, R2` : 레지스터 1과 2를 곱해서 레지스터 1에 넣어라.
  * `STORE 2:3, R1` : 레지스터 1의 결과를 다시 메모리 (2,3)에 저장해라.  
  
두 구조 사이에는 절대적인 우열은 없으며, 사용 목적·전력·성능·개발 환경 고려에 따라 적합한 선택이 달라집니다.
* 메모리 자원이 제한적이거나 코드 밀도가 중요한 초기 PC / 범용 컴퓨팅 환경 → CISC가 유리합니다.
* 배터리 효율, 예측 가능한 실행 시간, 병렬 처리 성능이 중요한 모바일·임베디드·HPC → RISC가 유리합니다.

(단, 최근에는 슈퍼컴퓨터도 전력대비 성능이 중요해지면서 ARM(RISC) 기반으로 전환하는 추세가 강해지고 있습니다.)

## CPU 기본 동작 흐름: Fetch -> Decode -> Execute
* CPU 동작 과정 사진 필요: CU, ALU, IR 레지스터.
1. 메모리에서 명령어를 Fetch
1. 명령어를 IR에 적재
1. CU가 명령어를 Decode
1. ALU가 연산 Execute 수행

## CISC
* CU의 역할
  * 명령어가 복잡하기 때문에, CU가 내부적으로 더 작은 단위의 명령(마이크로 연산)으로 분해해야 하는 경우가 많습니다.
  * 이 해석 과정 때문에 명령어 처리 시간이 길어질 수 있습니다.
* ALU와 메모리
  * 하나의 명령어 수행 중에, 메모리 접근과 연산이 여러 번 섞여 일어날 수 있습니다.
* 특징
  * 명령어의 길이가 가변적
  * Micro-code: 복잡한 명령어를 처리하기 위한 내부 제어 프로그램
  * 코드의 밀도가 높아 프로그램의 크기가 작아짐
  * 컴파일러 구현이 상대적으로 단순* 단점
* 단점
  * 회로 구조가 매우 복잡
  * 명령어마다 처리시간이 달라서 파이프라인 최적화가 어려움
* 예시
  * 인텔, AMD의 x86 아키텍처
  * 데스크톱, 노트북 PC, 서버 
## RISC
* CU의 역할
  * 명령어 길이가 고정
  * 명령어 형식이 단순해서 Decode 속도가 매우 빠릅니다.
* ALU와 메모리
  * Load / Store 구조: 메모리 접근은 LOAD / STORE 만 담당합니다.
  * 메모리 접근과 연산이 명확히 분리됩니다.
  * 결과적으로 레지스터에 있는 값만 가지고 매우 빠르고 예측 가능한 연산을 수행합니다. 
* 특징
  * 명령어 길이가 고정, 규칙화됨
  * Hard-wired Control: 마이크로코드 없이 회로가 직접 제
  * 파이프라이닝 적용에 매우 유리
  * 전력 소모가 적고 발열이 낮음
* 단점
  * 동일 작업에 더 많은 명령어(코드)가 필요
  * 컴파일러 품질이 성능에 큰 영향
* 예시
  * ARM 프로세서: 스마트폰, 자동차, 임베디드
  * Apple Silicon: M1, M2, M3 - 맥북, 아이패드
# 내가 이해한 바
# 개발자 관점에서 신경쓸 점
# 기술지원/고객 대응 관점에서 신경쓸 점
# 개선된 점 / 깨달음

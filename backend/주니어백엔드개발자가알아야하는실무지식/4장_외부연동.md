# 4장. 외부 연동이 문제일 때 살펴봐야 할 것들

---

## 🧠 ① 개념 중심 정리 버전

### 4-1. 외부 연동의 복잡성과 리스크
- 외부 연동은 점점 늘어나고 있다.  
  - 외부 API (PG사, 인증, 알림, 제3자 서비스)  
  - 내부 MSA 간 통신 (Gateway, Microservice, API chaining)
- **문제점:** 외부 시스템 장애 → 내부 서비스 장애로 전이  
  - 예: 외부 결제 서버 응답이 느려짐 → 우리 서버의 모든 스레드가 대기 → 전체 API 응답 지연 및 타임아웃 발생  

---

### 1️⃣ 타임아웃 (Timeout)
- 타임아웃 미설정 시, 외부 API 장애 → 우리 서버의 모든 스레드가 외부 응답을 기다리게 됨.
- **결과:** ThreadPool 포화 → 신규 요청 처리 불가 → 장애 확산.

#### 타임아웃의 3단계 (네트워크 핑퐁 흐름)
> ⚙️ 개념적으로 TCP의 **3-way handshake**가 연결 수립 과정이지만,  
> 여기서 말하는 3단계는 **응답 흐름(Connect → Request/Response → Close)**에 해당함.
1. **연결 시도와 성공 응답 (Connection Timeout)**  
   - 네트워크 연결 시도 단계  
   - 설정 예: 3~5초  
   - 너무 짧으면 불안정한 네트워크에서 실패율 증가
2. **요청 전송과 응답 수신 (Read Timeout)**  
   - 서버에서 응답을 받는 데 걸리는 최대 대기시간  
   - 설정 예: 5~30초  
   - 너무 짧으면 “결제 성공 but 응답 timeout” 같은 부조화 발생
3. **연결 종료**  
   - HTTP Keep-Alive 정책에 따라 커넥션 재사용 여부 결정

💡 **소켓 타임아웃(Socket Timeout)**  
→ 데이터 패킷 단위로 송수신할 때의 최대 대기시간으로, `readTimeout`과는 다름.  
HTTP 클라이언트 라이브러리(WebClient, RestTemplate 등)마다 용어가 다르므로 구체적인 설정항목을 확인해야 한다.

---

### 2️⃣ 재시도 (Retry)
- 외부 호출이 실패했을 때 “다시 시도해도 안전한가?”를 따져야 한다.

#### 재시도 가능한 경우
1. **단순 조회 요청** (`GET`)  
2. **연결 타임아웃 발생 시** (아직 요청이 전송되지 않음)  
3. **멱등성(Idempotency)**을 보장하는 변경 요청  
   - 예: “좋아요 API”는 여러 번 호출해도 한 번만 반영됨.

#### 재시도 전략
- 횟수: 1~2회 권장  
- 간격: 점진적 대기 (Exponential Backoff)  
  - 1초 → 2초 → 4초 ...  
- 실패 원인 필터링  
  - `400 Bad Request` → 재시도 ❌  
  - `500, 502, 504` → 재시도 ✅

---

### 3️⃣ 동시 요청 제한 (Concurrency Limit)
- 외부 서비스가 동시에 처리할 수 있는 요청 수를 초과하면 **우리 쪽에서 먼저 제한**.
- 초과 요청은 즉시 `503 Service Unavailable` 응답.

💬 **벌크헤드 패턴 (Bulkhead Pattern)**  
- 선박의 격벽처럼 **요청 자원을 분리**해 하나의 장애가 전체 시스템에 전파되지 않도록 하는 패턴.  
- 예: 외부 A서비스 호출용 스레드풀과 B서비스 호출용 스레드풀을 분리.  
- **구현 위치:**  
  - 자바 코드 레벨: Resilience4j, Hystrix 등  
  - 인프라 레벨: API Gateway (NGINX rate-limit, Envoy, Istio 등)

---

### 4️⃣ 서킷브레이커 (Circuit Breaker)
- 외부 서비스에서 지속적으로 오류가 발생하면 호출을 “끊어버리는” 보호 장치.

#### 3가지 상태
| 상태 | 의미 |
|------|------|
| **Closed** | 정상 호출 가능 |
| **Open** | 오류율이 임계치 초과 → 모든 호출 차단 |
| **Half-Open** | 일정 시간 후 일부 요청만 시도하여 회복 여부 확인 |

#### 구현
- **코드 레벨:**  
  - Java: [Resilience4j](https://resilience4j.readme.io/docs/circuitbreaker)  
  - Spring Boot 2.3+에서는 `spring-cloud-circuitbreaker-resilience4j` 기본 제공  
- **인프라 레벨:**  
  - Istio, Envoy, Spring Cloud Gateway의 retry/timeout/circuit-breaker 정책  

---

### 5️⃣ 외부 연동 + DB 트랜잭션 처리
#### 1. 외부 연동 실패 시 롤백
- 대부분은 DB만 롤백하면 되지만,  
  “읽기 타임아웃 발생” 시 외부 서비스가 실제로 성공했을 수도 있다.

**해결책**
1. **정기 동기화(batch 보정)**  
   - 가장 현실적인 방법 (예: 하루 1회 불일치 데이터 보정)  
2. **성공확인 API 호출**  
   - 일정 시간 뒤 재확인 → 성공이면 커밋, 실패면 롤백  
3. **취소 API 호출**  
   - 외부 서비스가 제공하는 경우에 한해 사용

#### 2. 외부 연동 성공 but DB 실패
- DB 트랜잭션이 롤백되면 외부 상태와 불일치 발생  
- 외부 호출 중 DB 커넥션을 점유하면 **풀 포화** 위험  
→ 외부 연동은 트랜잭션 밖에서 실행 (비동기 처리 or 이벤트 기반)  
→ 단, 커밋 이후 실패 가능성 대비 **보상 트랜잭션(Compensation Transaction)** 고려

---

### 6️⃣ HTTP 커넥션 풀 관리
- DB와 마찬가지로 **HTTP 커넥션 풀**도 연결/응답속도에 직접 영향.

#### 주요 설정
| 항목 | 설명 |
|------|------|
| **최대 커넥션 수** | 연동 서비스 처리 능력에 맞게 설정 (너무 크면 응답지연) |
| **커넥션 대기시간** | 커넥션을 가져오기 위한 최대 대기시간 (1~5초 권장) |
| **Keep-Alive (유지시간)** | 커넥션을 재사용할 최대 시간. `Keep-Alive: timeout=5` 형태로 설정 가능. |
| **라이브러리 별 관리** | Spring WebClient(Netty), Apache HttpClient, OkHttp 등 각자 커넥션 풀 내장. Spring Boot는 HttpClient 기반으로 통합 관리 가능. |

---

### 7️⃣ 연동 서비스 이중화
- 한 외부 서비스의 장애가 전체 매출/서비스에 치명적이라면 **이중화 필수**
- 예: 결제, 인증, 로그인 서비스

#### 이중화 판단 기준
1. 서비스 핵심 기능인가?  
   - 결제 ✅ / 로그 수집 ❌  
2. 이중화 비용이 감당 가능한가?  
   - 인프라 비용 + 운영 복잡도 고려

---

## ⚙️ ② 실무 중심 정리 버전

| 항목 | 실무 포인트 | 설정/구현 가이드 |
|------|-------------|------------------|
| **Connection Timeout** | 연결 자체에 걸리는 최대 시간 | 3~5초 |
| **Read Timeout** | 응답 대기 최대 시간 | 5~30초 (기능별 조정) |
| **Retry** | GET/멱등 API만 허용 | 최대 2회, 지수적 백오프 적용 |
| **Bulkhead Pattern** | 외부 서비스별 스레드풀/큐 분리 | Resilience4j `Bulkhead` or Gateway rate-limit |
| **Circuit Breaker** | 오류율 50% 이상 → Open 전환 | Resilience4j 설정: `failureRateThreshold`, `waitDurationInOpenState` |
| **트랜잭션 보정** | 성공확인/취소 API or 배치 동기화 | 보정 배치 1회/일 |
| **외부 연동 분리** | DB 트랜잭션 외부로 분리 | 이벤트 기반 or 비동기 호출 |
| **HTTP 커넥션풀** | 라이브러리별 커넥션 재사용 | WebClient, OkHttp, ApacheHttpClient |
| **Keep-Alive** | 커넥션 유지시간 | `Connection: keep-alive` / `Keep-Alive: timeout=5` |
| **이중화** | 핵심 서비스만 적용 | 결제, 인증, 알림 등 |
| **Fail-Fast 설계** | 외부 장애 시 빠르게 실패 반환 | 타임아웃 + 서킷브레이커 조합 |
| **Fallback 처리** | 차선 응답 제공 | 캐시된 데이터, 기본 메시지 등 |
| **모니터링** | 외부 API latency / error율 시각화 | Prometheus + Grafana / NewRelic |

---

## 💬 보충 설명 (물음표 해설)

| 질문 | 답변 |
|------|------|
| “3 handshake인가?” | 비슷한 개념이지만, 여기선 TCP 3-way handshake가 아니라 “연결-요청/응답-종료”라는 HTTP 통신 흐름 단계를 의미함. |
| “벌크헤드 패턴?” | 시스템 리소스를 격벽처럼 나눠 장애 전파를 막는 아키텍처 패턴. 스레드풀·큐를 서비스별로 분리해서 구현. |
| “서킷브레이커 구현은 자바 코드로?” | Resilience4j, Spring Cloud CircuitBreaker로 코드 레벨 구현 가능. 또한 Istio/Envoy 등의 인프라 계층에서도 정책 설정 가능. |
| “HTTP 커넥션 풀은 webclient가 관리?” | 네, Spring WebClient(Netty 기반)는 자체 커넥션 풀을 관리하며, 커넥션 크기·유지시간·대기시간 설정 가능. ApacheHttpClient/OkHttp도 유사. |
| “keep-alive 사용법?” | `Connection: keep-alive` 헤더를 추가하고, `Keep-Alive: timeout=5, max=100` 등으로 유지시간·요청수 지정. |

---

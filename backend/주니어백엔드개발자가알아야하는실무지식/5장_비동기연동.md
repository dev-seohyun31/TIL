# 5장. 비동기 연동, 언제 어떻게 써야할까

---

## 🧠 ① 개념 중심 정리 버전

### 5-1. 비동기의 개념
- **비동기(Asynchronous)**: 요청한 작업이 끝날 때까지 기다리지 않고 다음 작업을 수행.  
- 외부 연동 시, 실패가 전체 실패로 이어지지 않도록 **비동기화**가 필요함.  
  - 예: 포인트 지급 실패 → 로그인 실패 ❌  
- 외부 연동 응답이 느려 전체 응답시간이 늘어날 경우에도 비동기 처리로 개선 가능.

---

### 1️⃣ 비동기 연동이 필요한 상황
| 사례 | 설명 |
|------|------|
| 푸시 알림 서비스 | 주문 발생 시 판매자에게 알림 |
| 포인트 지급 서비스 | 학습 완료 후 포인트 적립 |
| 검색 서비스 | 컨텐츠 등록 후 색인 등록 |
| SMS 발송 서비스 | 인증번호 문자 전송 |

#### 공통 특징
1. **시차 허용 가능** (조금 늦게 처리되어도 문제 없음)  
2. **재시도 가능**  
3. **수동 처리 기능 존재**  
4. **실패해도 무시 가능**

---

### 2️⃣ 비동기 구현 방법

#### (1) 별도 스레드로 실행
- 직접 스레드를 생성하거나 Executor/ThreadPool 사용.  
  ```java
  executor.submit(() -> pushClient.sendPush(data));
  ```
- Spring: `@Async` 어노테이션 활용.  
  - 메서드 이름은 `async`로 명시 (`sendPushAsync()` 등).
- ⚠️ **주의: 예외 전파 X**
  - `@Transactional`은 AOP 기반으로 **동기 스레드에서만 작동**.
  - 비동기로 실행되면 새로운 스레드 컨텍스트이므로 **트랜잭션 경계 밖**.  
  - 예외가 발생해도 원래 트랜잭션에 영향을 주지 않음.
  - → 비동기 내부에서 **직접 try-catch** 처리 필요.

---

#### (2) 메시징 시스템 이용
- 시스템 간 실시간 데이터 전송을 중계.  
- **장점:** 시스템 간 결합도 낮음, 트래픽 독립성 확보, 확장성 우수.  
- **단점:** 구조 복잡, 운영 난이도 상승.

| 메시징 시스템 | 특징 | 적합한 경우 |
|----------------|--------|---------------|
| **Kafka** | 파일 기반 저장, 유실 없음, 순서 보장 약함, Pull 모델 | 초대규모 트래픽 (백만건/초) |
| **RabbitMQ** | 순서 보장, Push 모델, 메모리 기반 | 순서 중요/소규모 트래픽 |
| **Redis Pub/Sub** | 지연 짧음, 구독자 없으면 유실 | 경량 이벤트 처리 |
| **기타** | NATS, ActiveMQ, AWS SQS 등 | 클라우드·서드파티 환경 |

#### 메시지 생성 시 주의
1. **메시지 유실 방지**
   - 전송 실패 시 처리 전략:
     1. 무시 (로그용)
     2. 재시도 (중복 메시지 대비 — 고유 ID로 중복 체크)
     3. 실패 로그(DB/File)에 저장 후 후처리
2. **DB 트랜잭션 분리**
   - 트랜잭션 중간에 메시지 발송 ❌  
   - **트랜잭션 커밋 이후 발송** or **아웃박스 패턴** 사용

#### 메시지 소비 시 주의
1. **중복 메시지 처리**
   - 고유 ID 추적 or 멱등성 보장 API 설계
2. **모니터링**
   - 큐 적체 여부 감시 (적체 시 생산자도 영향받음)

#### 메시지 유형
| 유형 | 설명 | 예시 |
|------|------|------|
| **이벤트(Event)** | 상태 변화 알림 | 주문 완료, 배송 시작 |
| **커맨드(Command)** | 작업 요청 | 포인트 지급, 알림 발송 |

---

#### (3) 트랜잭션 아웃박스 패턴
- DB 트랜잭션과 메시지 전송을 **정합성 있게 묶는 패턴**.
- 메시지를 DB 테이블에 저장(아웃박스) → 별도 프로세스가 Polling 후 전송.
  - 즉, 메시징 시스템 장애 시에도 **데이터 유실 방지**.
  - 트랜잭션이 롤백되면 메시지 기록도 함께 롤백.
  - 상태 컬럼(`status`) 또는 메시지 ID(`messageId`)로 처리 추적 가능.
- **예시 테이블**
  ```
  id | messageId | messageType | payload | status | failCount | occurredAt | processedAt
  ```

---

#### (4) 배치 연동
- **전통적인 비동기 처리 방법.**
- 일정 주기로 파일/API를 통해 데이터를 전송.
  - 생산자: DB 조회 → 파일 저장 → 전송  
  - 소비자: 파일 읽기 → 처리 → 백업 이동
- 주의: 파일 생성 중 오류 발생 시 **재처리 기능** 필요.

---

#### (5) CDC (Change Data Capture)
- DB의 변경 로그를 기반으로 **데이터 변경 이벤트를 전파**.
- 예: MySQL binlog, PostgreSQL logical decoding.
- **활용 예시**
  - 신규 주문 시스템에서 발생한 주문을 기존 시스템에도 반영해야 할 때
  - 신규 시스템에 직접 연동 코드 추가 부담이 클 때  
    → CDC로 기존 DB 변경을 감지하여 자동 동기화.
- 메시징 시스템(Kafka 등)과 함께 사용 시 확장성 우수.

---

## ⚙️ ② 실무 중심 정리 버전

| 항목 | 실무 포인트 | Best Practice |
|------|--------------|----------------|
| **비동기 사용 시점** | 응답에 영향 없는 연동 처리 | 푸시, 포인트, 로그, 검색 색인 |
| **스레드 기반 비동기** | `@Async` 또는 Executor 사용 | 예외 직접 처리, 트랜잭션 경계 분리 |
| **메시징 시스템 선택** | 트래픽/순서/지속성에 따라 선택 | Kafka(대규모), RabbitMQ(순서), Redis(간단) |
| **재시도 설계** | 중복 방지 ID 필수 | UUID or 메시지 해시값 |
| **트랜잭션 경계** | DB 커밋 이후 발송 | Outbox 패턴 활용 |
| **Outbox 패턴** | 트랜잭션 정합성 보장 | 별도 Poller or Worker 구성 |
| **배치 처리** | 재처리 기능, 로그 파일 보관 | 파일명 규칙 + 백업 폴더 이동 |
| **CDC 사용** | DB binlog 기반 변경 감지 | Debezium + Kafka 조합 |
| **모니터링** | 큐 적체량, 실패율 시각화 | Prometheus + Grafana |
| **비동기 오류 처리** | 실패 로그/Retry 큐 설계 | Dead Letter Queue (DLQ) 사용 |
| **트랜잭션 아웃박스 구현** | `status` + `processedAt` 칼럼 관리 | 실패 시 `failCount` + 재시도 로직 |

---

## 💬 보충 설명 (물음표 해설)

| 질문 | 답변 |
|------|------|
| “@Transactional은 왜 비동기에서 안 먹히는가?” | Spring AOP는 프록시 기반이므로, **같은 스레드 컨텍스트에서만 작동**한다. 비동기는 새 스레드에서 실행되기 때문에 트랜잭션 경계 밖에 있다. |
| “poll 방식으로 직접 구현?” | 네. Outbox 테이블을 주기적으로 조회(Polling)해 메시지를 전송하는 별도 Scheduler 또는 Worker를 구현한다. (예: `@Scheduled` or Kafka Connect Debezium) |
| “DB 트랜잭션 분리 이유?” | 트랜잭션 중간에 메시지 전송하면 롤백 시 불일치 발생. 반드시 커밋 이후 발송. |
| “메시지 유실 대비는?” | DLQ(Dead Letter Queue) 사용 또는 실패 로그에 저장 후 배치 재처리. |
| “CDC 활용 언제?” | DB 변경 이벤트를 다른 시스템으로 자동 전파할 때. 신규/레거시 시스템 통합 시 유용. |

---

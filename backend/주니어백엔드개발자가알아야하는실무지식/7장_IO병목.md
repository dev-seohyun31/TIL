# 7장. IO 병목, 어떻게 해결하지 — 이론 & 실무 정리

---

# 🧭 ① 이론 중심 정리본 — IO 병목과 해결 전략

## 1️⃣ IO 병목의 본질

- **서버 프로그램은 네트워크 입출력(IO)** 을 기반으로 동작한다.  
  예:  
  - 클라이언트 ↔ 서버: HTTP 통신  
  - 서버 ↔ DB: TCP 기반 쿼리 송수신  
- 개발자는 네트워크 코드를 직접 작성하지 않아도, 내부적으로는 `OutputStream.write()`로 데이터를 전송하고 `InputStream.read()`로 수신한다.  
- **문제는 “IO 동안 스레드가 아무 일도 하지 않는 대기 상태(Blocking)”에 놓인다는 점.**  
  - CPU가 놀고 있는 동안도 스레드는 점유되어 있으므로 효율이 떨어진다.  
  - IO는 CPU 연산보다 **수십~수백 배 느리다**.

---

## 2️⃣ 톰캣 스레드 모델과 자원 비효율

- 톰캣은 기본적으로 **요청당 스레드 1개**를 할당한다.
- 트래픽이 증가하면 다음 이유로 비효율이 커진다:
  1. **IO 대기 중 CPU가 낭비**된다 (컨텍스트 스위칭 오버헤드 발생)
  2. **스레드 스택 메모리**가 요청 수만큼 증가한다
- 단, 수천만 트래픽이 아닌 일반 서비스에서는 CPU/메모리 부족보다 **다른 병목(DB, 외부 API)** 이 더 흔한 원인이다.
- 서비스가 성장하며 트래픽이 늘면,  
  1️⃣ 수직/수평 확장으로 즉시 완화하고,  
  2️⃣ 이후 구조적 IO 효율 개선으로 장기 대응한다.

---

## 3️⃣ CPU·메모리 자원을 늘리지 않고 처리량 높이는 두 가지 방법

### 🧩 1. 경량 스레드(가상 스레드, 고루틴) — 메모리 효율 개선

- **OS 스레드가 아닌 JVM 런타임이 직접 관리하는 스레드.**
  - OS 스케줄러가 아니라 **JVM 스케줄러**가 여러 가상 스레드를 번갈아 실행.
  - 플랫폼 스레드(=OS 스레드)가 여러 가상 스레드를 번갈아 실행한다.
- **장점**
  - 스택 메모리 사용량이 작고, 생성 속도가 빠르다.
  - IO 중심 작업에 적합.
  - 수만 개 요청을 처리할 때 메모리 사용량이 기존 대비 수백 배 절감 가능.
- **동작 구조**
  - 가상 스레드가 블로킹되면 플랫폼 스레드에서 *언마운트*되고,
    JVM이 다른 가상 스레드를 대신 실행시켜 CPU 낭비를 막는다.
- **주의점**
  - CPU 연산 위주(CPU-bound) 작업에서는 오히려 성능 저하 가능.
  - 가상 스레드 수 > 플랫폼 스레드 수 여야 효과가 있다.
  - CPU 코어 수를 늘리는 것보다, IO 중심일 때 적합.
- **핵심 포인트**
  - 가상 스레드는 “처리량(Throughput)”을 늘릴 뿐,
    **개별 요청의 실행 속도는 빨라지지 않는다.**

---

### ⚙️ 2. 논블로킹/비동기 IO — CPU 효율 개선

- 경량 스레드로도 한계가 오면, IO 구조를 **논블로킹 IO**로 변경해야 한다.
- **논블로킹 IO**: IO 요청을 보내고 **즉시 리턴**, 결과는 나중에 이벤트로 처리.  
  (즉, 스레드는 대기하지 않음)
- **비동기 IO**: 논블로킹 IO + 콜백 방식으로 처리 완료 이벤트를 수신.
- **예시 기술**
  - Node.js, Netty, Nginx, Spring WebFlux(Reactor 기반)
- **핵심 구조: 리액터 패턴(Reactor Pattern)**
  - 이벤트 루프(reactor)가 IO 이벤트를 감지하고,
  - 등록된 핸들러(handler)가 해당 이벤트를 처리.
  - 하나의 스레드(또는 적은 수의 스레드)가 수천 개 IO를 관리.
- **예시**
  - 블로킹 IO: 1000 요청 = 1000 스레드 필요  
  - 논블로킹 IO: 1000 요청 = 4~8개의 스레드로 처리 가능
- **장점**
  - CPU 대기 낭비 최소화
  - 스레드 수 절감 → 메모리 효율 향상
- **단점**
  - 코드 복잡도 ↑, 디버깅 어려움
  - 블로킹 API와 혼용 시 성능 저하

---

## 4️⃣ 어떤 방법을 선택할까?

| 판단 기준 | 확인 항목 | 대응 방법 |
|------------|------------|------------|
| ① 성능 문제 존재? | 응답 지연, 트래픽 급증 여부 | 문제 없으면 단순 확장으로 충분 |
| ② 병목 원인 IO인가? | DB/CPU/네트워크 중 병목 위치 확인 | DB면 튜닝/캐시, IO면 구조 개선 |
| ③ 구조 변경 가능? | 개발 인력, 일정, 기술 스택 | 불가능 시 서버 확장으로 완화 |

---

## 5️⃣ 요약

| 항목 | 설명 | 비고 |
|------|------|------|
| **가상 스레드** | JVM이 관리하는 경량 스레드 | IO 중심에 적합, CPU 작업엔 비효율 |
| **논블로킹 IO** | 스레드 대기 없이 이벤트 기반 처리 | Reactor, Netty, WebFlux |
| **비동기 IO** | 논블로킹 IO + 콜백 구조 | 고성능 서버용 |
| **적용 시점** | 트래픽 급증, IO 대기 과다 | 초기 서비스엔 과도 |
| **부적합 사례** | CPU 연산 중심 서비스 | 오히려 성능 저하 |

---

# 🛠 ② 실무 중심 정리본 — 개발자 관점의 적용 전략

## 🧠 1. IO 병목 징후 파악하기
- CPU 사용률은 낮은데 **응답시간이 점점 늘어난다**  
  → 대부분 IO 대기 (DB, 외부 API, 파일 시스템 등)
- **스레드 덤프(Thread dump)** 에 `WAITING`, `BLOCKED` 상태가 많다  
  → 블로킹 IO 의심
- **톰캣 스레드 풀 모니터링**  
  - `maxThreads` 대비 active thread 비율이 높으면 스레드가 IO에 묶여 있다.

---

## ⚡ 2. 경량 스레드 적용 시나리오
- Java 21+ 에서 `VirtualThreadPerTaskExecutor` 로 손쉽게 적용 가능  
  ```java
  try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
      executor.submit(() -> service.callExternalAPI());
  }
  ```
- 적용 기준:
  - 대부분의 요청이 **DB·외부 API 중심(IO-bound)** 일 때
  - 스레드 수가 많아 **메모리 사용률 80% 이상**일 때
- 주의사항:
  - 비동기 콜백 구조로 섞지 말 것 (디버깅 어려움)
  - CPU 연산이 많은 경우 기존 플랫폼 스레드 유지

---

## 🔄 3. 논블로킹/비동기 IO로 전환
- **Spring MVC → WebFlux(Netty 기반)** 로 마이그레이션 가능
- 예시:
  ```java
  WebClient client = WebClient.create("https://api.example.com");
  Mono<String> result = client.get().retrieve().bodyToMono(String.class);
  ```
- 단, 다음과 같은 경우에는 신중히 검토:
  - 기존 동기 코드/라이브러리와 섞여야 하는 경우
  - 트랜잭션 관리가 중요한 비즈니스 로직

---

## 🧩 4. 점진적 확장 전략
1. 단기: 수평/수직 확장으로 즉시 대응 (Load Balancer, Auto Scaling)
2. 중기: DB 튜닝·캐시 적용 (RDS Proxy, Redis, etc.)
3. 장기: IO 구조 자체 개선 (가상 스레드 → 논블로킹 IO 전환)

---

## ✅ 실무 팁 정리

| 상황 | 해결책 | 비고 |
|------|---------|------|
| API 호출 응답이 느릴 때 | 가상 스레드로 변환 | IO-bound |
| 스레드 수 과다, 메모리 부족 | 비동기 IO 도입 | 고트래픽 환경 |
| CPU 점유율 높음 | 코드 로직 개선 or 병렬 처리 | CPU-bound |
| 응답시간은 짧지만 TPS 낮음 | Reactor 기반 논블로킹 구조로 전환 | 이벤트 루프 방식 |

---

## 💬 결론

> IO 병목은 서버의 “속도 문제”가 아니라 “대기 문제”다.  
> 해결의 핵심은 **스레드를 놀리지 않는 구조**로 바꾸는 것이다.  
> 초기엔 단순 확장으로도 충분하지만, 트래픽이 커질수록  
> **가상 스레드 → 비동기 IO → 논블로킹 아키텍처**로 진화해야 한다.

# 실제 개념
## Flash 메모리란
Flash 메모리란 전원이 꺼져도 데이터가 유지되는 비휘발성 메모리이며,
MCU에서는 프로그램 실행 공간이자 영구 데이터 저장 공간으로 사용됩니다.
Flash는 RAM과 달리 반도체 물리 구조 특성 때문에 읽기/쓰기/지우기 동작 특성이 크게 다릅니다.

## 물리적 특성
### 1. 읽기: 빠르고 자주 해도 됨
* 메모리맵 구조로 CPU 버스에 직접 연결됩니다.
* 별도 복사없이 CPU가 Flash 주소에서 IF를 바로 수행할 수 있습니다. (XIP, Execute in Place)
* 읽기는 셀 구조를 파괴하지 않는 비파괴 동작입니다.
* 따라서, 읽기 횟수 제한없이 코드 실행과 상수 접근에 자유롭게 사용될 수 있습니다.

### 2. 쓰기: Page 단위로 느림
* 전기적으로 셀의 전하 상태를 변경하는 작업이어서, 고전압 펄스를 이용한 셀 충전 과정이 필요하고, 셀 안정성 확보를 위한 내부 verify 과정을 포함해야 하기 때문에 느립니다. (?)
* Page 단위(예: 32B, 64B, 256B 등)로만 program 가능하고, 바이트 단위로 overwrite는 불가능합니다. 따라서 쓰기 전에 반드시 지우기 과정이 필요합니다. 
* 예: 4B만 수정해도 실제 내부 동작은 `Page 전체 읽기 -> RAM 복사 -> 필요한 데이터 수정 -> Page 전체 다시 program` 과정을 거칩니다.
 
### 3. 지우기: Sector/Block 단위로 제일 느림
* 대규모 셀 배열을 동시에 리셋하고, 내부 전압 안정화 및 검증 과정이 포함되어야 하기 때문에 제일 느립니다.
* 바이트 단위가 아니라, 섹터 단위(예: 4KB, 8KB, 64KB)로만 가능합니다.
* 섹터 전체 셀을 초기상태로 복원하고 지우기 없이는 프로그램이 불가합니다. 즉, 특정 주소만 지울 수는 없고 같은 섹터에 속한 모든 데이터가 함께 삭제됩니다.

## MCU에서의 Flash
Flash의 위 특성들 때문에 MCU에선는 다음 목적으로 사용됩니다. 
### 1. 프로그램 코드 저장
CPU가 Flash에서 직접 실행하는 main(), ISR, Driver, RTOS, Interrupt Vector Table이 저장됩니다. 
### 2. 영구 데이터 저장
설정값(config), Calibration Data, 시리얼 번호, 로그 등이 저장될 수 있지만, erase/program 횟수 제한떄문에 RAM처럼 자유로운 저장소로 사용하면 안됩니다.

## Aurix에서의 Flash
AURIX에서는 Flash를 논리적으로 분리하여 컨트롤러, 접근 특성, 용도를 나누어서 사용합니다.
### PFlash
* 프로그램 코드 저장 및 명령어 fetch 용도
* 예: mian(), ISR, OS, Driver code, Bootloader
### DFlash: 
* 데이터 저장 용도
* 예: 설정값, 보정 데이터, 시리얼 번호 등
# 내가 이해한 바 
서버개발과 달리, 실행 공간(메모리)와 저장공간(디스크)가 분리되어 있지 않고 CPU와 바로 연결되어 있어서 IF를 직접 수행한다. 
# 개발자 관점에서 신경쓸 점 
## 1. Flash는 RAM보다 느리므로, ISR, Loop에서 Flash 접근이 많으면 pipeline stall 이 걸릴 수도 있다.  
이런 경우, 크리티컬 코드는 RAM에 배치하는 방법이 있다. 
```C
__attribute__((section(".ramcode")))
void fast_function(void)
{
    // 타이밍 민감 코드
}
```
## 2. Flash 수명에 유의한다
쓰기 회수 제한이 있으므로 (일반적으로 10만~100만번 erase cycle) 설정값을 주기적으로 저장하지 말고 waar leveling 설계(?)가 필요하다. 
# 기술지원/고객 대응 관점에서 신경쓸 점 
# 개선된 점 / 깨달음






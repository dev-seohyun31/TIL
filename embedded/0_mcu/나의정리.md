# MCU

MCU는 물리 세계를 실시간으로 제어하기 위한 컴퓨터입니다.
일반 PC나 서버처럼 높은 처리량과 연산 성능을 목적으로 하는 반면, MCU의 목적은 정해진 시간 안에 반드시 반응해야 하는 실시간 제어입니다.

MCU는 하나의 칩에 다음 구성 요소를 가지고 있어, 컴퓨터로 동작하기 위한 골격을 만듭니다.
* CPU: 프로그램 실행, 연산을 담당
* Memory: 코드 저장과 CPU의 데이터 처리를 위한 공간 제공
* Peripheral: CPU를 물리 세계와 연관되게 하는 독립된 장치


실시간 제어 목적을 달성하기 위해, 위의 기본 구성 외에도 다음과 같은 시스템 지원 블록이 함께 있습니다.
* Interrupt System: 이벤트 기반 실시간 시스템 구현
* Power Management System: 이벤트 기반에서 저전력 구현


# 주요 구성요소
## CPU 
CPU는 기본적으로 CU, ALU, Register로 구성되어 있어서 다음 순서로 연산합니다. 
1. 메모리에서 명령어를 Fetch
2. 명령어를 Register에 저장
3. CU가 명령어를 해독
4. ALU가 명령어 실행

여기서 명령어 구조가 전부 표준으로 작성되었는지, 아닌지에 따라 RISC, CISC로 분류되는데, 
MCU는 주로 표준으로 명령어 길이가 고정된 RISC를 사용합니다. 

RISC는 명령어 길이가 고정되어 있기 때문에 명령어를 잘게 쪼갠 단위 안에서 병렬 연산이 가능해집니다. 
병렬 깊이가 깊을수록 회로가 복잡해지기 때문에 MCU에서는 적당히 3~6단계만 처리하는 편입니다.
단, 이런 병렬 설계는 피할 수 없는 부작용이 몇개 있는데, 명령어가 처리되지 못하고 대기(stall)하거나 계산되고 있는 상태를 버려야(flush) 할 수 있습니다. 
따라서 이를 피하는 방향으로 코딩을 하는 것이 좋습니다. (하지만 그렇게 큰 영향은 없다고는 합니다)

또한, 실시간 이벤트를 처리하기 위한 인터럽트 시스템이 있어서, 이벤트가 발생하면 파이프라인의 마지막 명령어를 commit처리하고 나머지는 전부 버리는 (flush) 작업을 진행합니다. 
인터럽트는 Flash 메모리의 인터럽트 벡터 테이블을 조회하여 인터럽트를 실행하고, 인터럽트가 끝나면 본래 코드로 복귀합니다. 

### 클록
CPU가 엔진이라면, 클록은 엔진을 실행하게 하는 심장이라고 할 수 있습니다. 
클록을 생성하는 하드웨어 회로인 오실레이터는 파워 ON 이후에 구동됩니다. 
이 내부 오실레이터는 다소 오차 범위가 높아서, 어느정도 시간이 지나면 정확도가 높은 외부 크리스탈 오실레이터와 증폭기인 PLL로 시스템 클록을 전환합니다.

이렇게 생성된 클록에 맞춰서 CPU가 명령어를 실행시키며, 명령어 실행 타이밍이 모두 동기화되기 때문에 시스템이 엉키지 않게 구동될 수 있습니다.

## 메모리
MCU의 저장소는 아래 종류가 있습니다. 
* **RAM**: 런타임 데이터를 data, stack, heap에 저장
* **Flash**: 코드와 읽기전용 데이터를 저장
* **ROM**: 부트 저장
* **주변장치의 레지스터**: 주변장치와 관련된 값 저장
* **시스템 제어 저장소**: 인터럽트 벡터 테이블 등 저장
 
**메모리 맵**은 이 저장소들을 주소로 모두 저장하고 있어서 CPU가 바로 접근 가능하도록 설계되었습니다. 
(런타임에 필요한 모든 데이터를 RAM에 올려서 작업하는 PC와 사뭇 형태가 다릅니다.)

MCU에 코드를 Flash하게 되면, 링커가 자신의 스크립트를 읽고 이 저장소들에 코드 및 데이터를 적재하여 실행을 준비합니다.

---

이렇게 CPU가 메모리로 명령어들을 어떻게 실행시키는지 알았지만, 사실 CPU가 작업할 수 있는 명령어는 ADD, SUB 등 CPU에서 자체 처리할 수 있는 명령어들과 STORE, LOAD같이 메모리와 소통할 수 있는 명령어 두종류 뿐입니다. 
따라서 본래 MCU의 목적에 맞게 **하드웨어 제어**를 하기 위해서는 독립적인 추가 장비가 필요합니다.

## 주변장치
주변장치의 종류는 다음이 있습니다.
(여기서 주변장치는 하드웨어 제어를 위한 장치 뿐만 아니라, CPU가 하지 못하는 시스템 제어 장치까지 포함시켰습니다.)
* **기본 디지털 입출력**: MCU 핀과 연결되어 전압(0/3.3V)과 레지스터 변환 **(GP Input & output)**
* **아날로그 입출력**: MCU 핀과 연결되어 전압(0~3.3V)와 레지스터 변환 **(ADC, DAC)**
* **통신**: 단순 외부장치부터 여러 ECU와 통신하기 위한 데이터 송신과 수신 **(UART/SPI/I2C, CAN/LIN/Ethenrnet)**
* **시간**: 클록과 카운터를 활용한 시간 변환 **(Timer)**
* **시스템**: 메모리 자동 접근, 인터럽트 제어 **(DMA, Interrupt Controller, ..)**

각 주변장치들은 보통 컨트롤러와 자체 레지스터를 갖고 있습니다. 
CPU는 주변장치의 레지스터 값을 가져오기 위해 버스를 타고 왔다갔다 하며, 버스는 주소/데이터/제어 3가지 모두 다닙니다.

각 주변장치들은 각자의 목표를 달성하기 위해 각각의 컨트롤러와 회로 기술이 존재합니다.

### 핀
핀의 모드는 다음 종류가 있어서 개발자가 핀의 목적에 따라 조합해서 선택할 수 있습니다. 
* Input / OUtput (포트 옵션): 입력과 출력 택1
* Pull-up / Pull-down (핀 옵션): 기본값이 1이냐, 0이냐
* Push-pull / Open-drain (핀 옵션): 0과 1을 명확히 하느냐, 0만 명확히 하느냐
* GPIO / Alternative Function (핀 옵션): GPIO 용도로 쓸 것이냐, 그 외의 용도이냐

---
## 참고) 데이터 주고받는 원리: 버스 시스템
CPU와 메모리, CPU와 주변장치 레지스터, CPU와 Flash가 서로 데이터를 주고받을 수 있는 이유는 서로 직접 연결되어서가 아니라, 중앙에 Bus Interconnect가 모든 통신경로를 관리하고 있기 때문입니다.

Bus Interconnect는 CPU, 메모리 컨트롤러, 주변장치 레지스터 인터페이스 등을 버스로 연결하고 있습니다. 
버스는 각각 주소 버스/데이터 버스/제어 버스 세가지 묶음으로 관리하는데, Bus Interconnect는 주소를 해석하고 중재 후 데이터를 전달합니다.

프로토콜 종류로는 AXI, AHB, APB가 있는데, burst를 지원하는 고속 버스는 AXI와 AHB, FSM 기반으로 동작하는 저속 버스는 APB입니다.
AXI/AHB는 CPU, 메모리, Flash 등에 적합한 반면, APB는 레지스터 접근에 적합합니다. 
APB는 AXI/AHB와 프로토콜 구조와 속도가 다르기 떄문에, 이를 조절할 수 있는 bridge를 APB측에 두어야 합니다.


# 실시간 시스템
위의 구성요소에 추가로, MCU가 실시간 이벤트 역할을 할 수 있도록 다음 시스템이 하드웨어 기반으로 존재합니다. 
## Interrupt System
인터럽트 시스템은 CPU가 이벤트를 polling하지 않고도 이벤트를 즉시 처리할 수 있도록 하는 시스템입니다. 
CPU와 별도로 인터럽트 컨트롤러를 두어서 이벤트 감지, 우선순위 판단, 중재 처리를 담당하여 역할분리를 합니다.

1. ISR과 ISR의 시작 주소를 저장한 Vector Table은 일반적으로 Flash 메모리에 저장됩니다. 
2. 주변장치 등에서 인터럽트 이벤트가 발생하면, 해당 주변장치는 IRQ Line을 통해 인터럽트 컨트롤러에 신호를 보냅니다. 
3. 인터럽트 컨트롤러는 인터럽트들의 우선순위를 판단한 후, 1개를 선택하여 CPU에게 인터럽트 요청 신호와 Vector 번호를 전달합니다.
4. CPU는 실행 중이던 흐름을 중단하고 context 저장, flush, vector table 참조, ISR 시작 주소로 점프, fetch 및 실행합니다.

CPU가 인터럽트 처리 중에도 우선순위가 더 높은 인터럽트 요청이 발생하면 동일하게 작업됩니다. 
이를 "선점"이라고 하며, 긴급 이벤트의 빠른 대응을 보장할 수 있습니다.

## Power Management System
이벤트 기반 시스템에서는 이벤트가 없을 때 최소 전력을 유지하고, 이벤트가 있을 때만 정상 동작하는 것이 최선일 것입니다. 
MCU는 이를 위해 PMU가 cpu / memory / peripheral / backup 도메인으로 전력 구조를 분리하여 관리합니다.

`Sleep → Deep Sleep → Standby → Hibernate` 순으로 더 전력을 절감하며, 복귀 시간 지연은 증가합니다. 
* sleep은 CPU와 주변장치의 클록을 차단합니다. 인터럽트 발생 시에 빠른 복귀가 가능하여, 가장 일반적인 이벤트 대기상태입니다.
* deep sleep은 CPU와 주변장치의 전원을 차단하고 메모리는 데이터만 유지될 수 있는 최소 전압만 제공됩니다. 

실시간 시스템 개발 시, 주로 sleep을 기본 상태로 유지하고, 인터럽트 이벤트를 통해 필요한 순간에만 활성화되는 구조가 적합합니다.




# 실제 개념
## AURIX TC3xx CPU Architecture 개요
**AURIX TC3xx**는 Infineon TriCore v1.6.x 계열 CPU를 기반으로 설계된 **자동차 실시간 제어용 MCU**입니다.
TriCore는 단순히 연산 성능을 높이는 방향이 아니라, 다음과 같은 **실시간 제어 시스템의 요구사항**을 만족하도록 설계되었습니다.
* 짧고 예측 가능한 인터럽트 지연
* 일정한 실행 시간(Deterministic latency)
* 고속 수치 연산 처리
* 멀티코어 병렬 처리
* 기능 안전(Functional Safety) 대응

이를 위해 TC3xx CPU는 아래 4가지 핵심 구조를 갖습니다.

## 1. TriCore 구조 (= RISC + DSP + MCU Control Hybrid)
TriCore는 차량 ECU에서 동시에 요구되는 서로 다른 3가지 작업 성격을 하나의 코어에서 효율적으로 처리하기 위해 설계된 하이브리드 CPU 구조입니다.

### 1) **RISC 영역 - 제어로직 처리**
RISC 구조는 일반적인 제어 코드와 프로그램 흐름을 안정적이고 효율적으로 처리합니다.
조건 분기(if/switch), 상태 머신, 통신 프로토콜 처리, 시스템 제어 로직 등은 ECU 전체 동작 흐름을 제어하는 역할을 담당합니다.

### 2) **DSP** - 수치 연산 가속
자동차 제어 시스템에는 다음과 같은 반복적인 수치 연산이 매우 많이 등장합니다.
```C
sum += a[i] * b[i];cmd
```
이와 같은 MAC 연산은 모터 제어(FOC), 센서 필터링 (FIR/IIR), 제어기 계산(PID) 등에서 핵심입니다. 

TriCore는 이러한 연산을 한 사이클 또는 소수 사이클로 처리할 수 있도록 전용 DSP 연산 유닛과 명령어 확장을 제공합니다. 이를 통해 높은 수치 처리량과 안정적인 제어 주기 유지가 가능합니다.

### 3) **MCU 제어 기능** - 실시간 반응성과 안전성
TriCore는 단순 연산 처리뿐 아니라, 실시간 시스템 특화 제어 기능을 CPU 레벨에서 제공하는데, 주요 목적은 다음과 같습니다.
* 인터럽트 지연 최소화
* 빠른 컨텍스트 스위칭
* 기능 안전 메커니즘 연동

이를 위해 AURIX TC3xx CPU는 다음 구조를 사용합니다. 
* **CSA(Context Save Area)**: 인터럽트나 태스크 전환 시 레지스터 컨텍스트를 스택이 아닌 전용 하드웨어 관리 영역에 자동 저장 및 복원합니다. 이를 통해 인터럽트 진입/복귀 시간이 짧고 일정하게 유지됩니다.
* **Trap 기반 예외 처리 구조**: 잘못된 접근, 보호 위반, 시스템 오류 발생 시 즉시 트랩으로 전환되어 안전 모듈(SMU)과 연동 가능합니다.


### Tricore 구조 활용 예: 모터 제어 루프
모터 제어는 다음 순서로 흘러갑니다.
1. ADC로 전류/전압 센서 값 입력
1. 필터링 및 제어 연산 수행 (DSP 연산 집중 구간)
1. PWM 출력 값 계산 및 설정
1. 위 과정을 정해진 주기(예: 100µs) 안에 반복 수행
1. 과전류 발생 시 보호 인터럽트 즉시 처리

이 과정에서 DSP는 연산 처리, RISC는 제어 로직, MCU Control 구조는 실시간 반응성과 안정성을 동시에 담당합니다. 


## 2. Multi-core로 동기화 구조
AURIX TC3xx는 여러 개의 TriCore CPU(Core0/1/2)를 포함하는 멀티코어 MCU입니다.
각 코어는 독립적으로 실행되지만, 메모리와 주변장치를 공유하므로 동기화 메커니즘이 필수적입니다.

멀티코어 동기화는 다음 세 가지 상황에서 주로 발생합니다.

### 1) 부팅 및 시작 동기화
TC3xx의 기본 부팅 흐름은 다음과 같습니다. 
```
Reset 발생
→ CPU0 부팅 시작
→ 시스템 클록, 메모리, 인터럽트 초기화
→ CPU1/CPU2 Release
→ 각 코어가 지정된 Entry Point에서 실행 시작
```
> 여기서 Release란, CPU1/CPU2의 리셋 상태를 해제하여 실제 코드 실행을 시작하도록 허용하는 하드웨어 제어 동작을 의미합니다.

CPU0가 시스템 초기화를 완료한 후 다른 코어의 실행을 시작시켜, 초기화 충돌을 방지합니다.
### 2) 데이터 공유 동기화 (Shared RAM)
여러 코어가 동일한 메모리를 접근할 때는 경쟁 조건(Race Condition)을 방지해야 합니다.
이를 위해 다음 방식이 사용됩니다.
#### (1) Lock 기반 동기화
Spinlock 또는 Mutex를 사용하여 임계 구역을 보호합니다.
짧은 시간 동안 보호가 필요한 구간에 적합합니다.
```C
IfxCpu_acquireMutex();
...
IfxCpu_releaseMutex();
```


#### (2) Atomic 연산
읽기-수정-쓰기(Read-Modify-Write)를 하나의 원자 동작으로 수행합니다.
예를 들어 카운터 증가, 플래그 업데이트는 락 없이도 데이터 무결성으 유지할 수 있습니다. 

#### (3) Memory Barrier
메모리 접근 순서를 강제하여 다음 같은 문제를 방지합니다: `플래그는 먼저 보이지만, 데이터는 아직 반영되지 않은 상태`

Barrier는 “쓰기 완료 후 신호 전달” 같은 동기화 시점에 사용됩니다.

### 3) 주변장치 공유 (Preipheral Ownership)
여러 코어가 하나의 주변장치를 동시에 제어하는 것은 위험하므로, 일반적으로 Owner Core 개념을 사용합니다.
* CAN → CPU2 전담
* UART Shell → CPU0 전담
* PWM → CPU1 전담

이 때, CPU는 자신이 전담하지 않는 레지스터 접근 시, 직접 레지스터 접근 대신 메시지 또는 인터럽트를 통해 전담 CPU로 요청합니다. 



## 3. Harvard 구조 + TCM 결합
TriCore는 Modified Harvard Architecture를 사용합니다.
> Harvard 구조는 명령어 버스와 데이터 버스를 분리하여, 명령어 Fetch와 데이터 Load/Store을 동시에 수행할 수 있습니다. 이는 파이프라인 효율을 크게 향상시킵니다.

### TCM (Tightly Coupled Memory)
Flash 메모리는 접근 지연이 크고 예측이 어렵기 때문에, TriCore는 CPU에 직접 연결된 고속 메모리인 TCM을 제공합니다.
다음 영역으로 나뉘어지며, 개발자는 링커 스크립트나 c파일에서 섹션을 분리하는 등 작성할 수 있습니다. 
* **P-TCM (Program TCM)**: ISR, 제어 루프, 안전 루틴과 같은 핵심 코드를 저장합니다. 
* **D-TCM (Data TCM)**: ISR 공유 변수, 제어 루프 반복 데이터를 저장합니다. 

TCM은 항상 일정한 접근 시간을 제공하므로 실시간 결정성을 보장합니다.

이렇게 Harvard 구조는 병렬성, TCM은 지연 시간의 예측 가능성을 제공합니다.
따라서 TriCore는 메모리 구조와 버스 구조를 함께 설계하여 실시간 제어에 최적화된 실행 환경을 제공합니다.

## 4. Context Save Area (CSA)
CSA는 인터럽트 또는 태스크 전환 시 CPU 레지스터 컨텍스트를 스택 대신 전용 하드웨어 관리 영역에 저장하는 구조입니다.

기존 Stack 방식에는 (1) 메모리 접근 지연에 따른 저장 시간 변동, (2) 중첩 인터럽트 증가 시 Stack overflow 위험, (3) RTOS context switching 성능 한계 문제가 있어서 CSA가 등장했습니다. 

#### CSA 구조
CSA는 RAM 내에 고정 크기의 블록 풀 형태로 구성됩니다.
각 CSA Block에는 다음 정보가 저장됩니다.
* Program Counter (PC)
* Program Status Word (PSW)
* General Purpose Registers
* Context Link 정보

TriCore 레지스터 구조는 CSA 저장에 최적화되어 설계되어, 하드웨어 기반 빠른 컨텍스트 전환이 가능합니다.



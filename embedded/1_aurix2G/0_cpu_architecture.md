# 실제 개념
## Infineon TriCore - CPU Architecture 개요
**AURIX TC3xx**는 Infineon TriCore v1.6.x 계열 CPU를 기반으로 설계된 **자동차 실시간 제어용 MCU**입니다.

TriCore는 단순히 연산 성능을 높이는 방향이 아니라, 다음과 같은 **실시간 제어 시스템의 요구사항**을 만족하도록 설계되었습니다.
* 짧고 예측 가능한 인터럽트 지연
* 일정한 실행 시간(Deterministic latency)
* 고속 수치 연산 처리
* 멀티코어 병렬 처리
* 기능 안전 대응

이를 위해 TC3xx CPU는 아래 4가지 핵심 구조를 갖습니다.

## 1. TriCore 구조
TriCore는 차량 ECU에서 동시에 요구되는 3가지 작업(제어/연산/실시간) 성격을 하나의 코어에서 처리하기 위해 **RISC + DSP + MCU Control Hybrid** 구조로 설계된 CPU입니다.
 
### 1) **RISC 영역 - 제어**
RISC 구조는 프로그램 흐름을 안정적이고 효율적으로 처리합니다.
조건 분기(if/switch), 상태 머신, 통신 프로토콜 처리, 시스템 제어 로직 등은 ECU 전체 동작 흐름을 제어합니다.

### 2) **DSP** - 고속 수치 연산
자동차 제어 시스템에는 다음과 같은 반복 수치 (MAC - Multiply-Accumulate) 연산이 모터 제어(FOC), 센서 필터링 (FIR/IIR), 제어기 계산(PID) 등에서 자주 등장합니다.
```C
sum += a[i] * b[i];
```
TriCore는 이러한 연산을 1 또는 소수 사이클로 처리할 수 있도록, DSP 연산 유닛을 제공합니다. 

### 3) **MCU 제어 기능** - 실시간 반응과 안전성
TriCore는 단순 연산 처리뿐 아니라, 실시간 시스템 특화 제어 기능을 CPU 레벨에서 제공할 수 있습니다.
1. 인터럽트 지연 최소화와 빠른 컨텍스트 스위칭을 위해, **CSA(Context Save Area)** 구조 사용
    * 인터럽트나 task 전환 시, context를 stack이 아닌 전용 하드웨어 영역에 자동으로 저장하고 복원합니다. 
    * CSA 블록은 하드웨어 전용 경로로 설계되어 있기 때문에, 속도도 고정적이고 빠릅니다.
1. 기능 안전을 위해 **Trap 기반 예외 처리 구조** 사용
    * 잘못된 접근, 보호 위반, 시스템 오류 발생 시 즉시 트랩으로 전환되어 안전 모듈(SMU)과 연동 가능합니다.

### Tricore 구조 활용 예: 모터 제어 루프
모터 제어는 다음 순서로 흘러갑니다.
1. ADC로 전류/전압 센서 값 입력
1. 필터링 및 제어 연산 수행 (DSP 연산 집중 구간)
1. PWM 출력 값 계산 및 설정
1. 위 과정을 정해진 주기(예: 100µs) 안에 반복 수행
1. 과전류 발생 시 보호 인터럽트 즉시 처리

이 과정에서 DSP는 연산 처리, RISC는 제어 로직, MCU Control 구조는 실시간 반응성과 안정성을 동시에 담당합니다. 


## 2. Multi-core로 동기화 구조
여러 개의 TriCore CPU(Core0/1/2)를 가진 AURIX TC3xx에서 각 코어는 독립적으로 실행되지만, 메모리와 주변장치를 공유하므로 동기화 메커니즘이 필수적입니다.

멀티코어 동기화는 다음 세 가지 상황에서 주로 필요합니다.

### 1) 부팅 및 시작 동기화
TC3xx의 기본 부팅에서 이미 동기화를 사용하고 있으며, 흐름은 다음과 같습니다. 
```
Reset 발생
→ CPU0 부팅 시작
→ 시스템 클록, 메모리, 인터럽트 초기화
→ CPU1/CPU2 Release
→ 각 코어가 지정된 Entry Point에서 실행 시작
```
> 여기서 Release란, CPU1/CPU2의 리셋 상태를 해제하여 실제 코드 실행을 시작하도록 허용하는 하드웨어 제어 동작을 의미합니다.

이처럼 CPU0가 시스템 초기화를 완료한 후 다른 코어의 실행을 시작시켜, 초기화 충돌을 방지합니다.

### 2) 데이터 공유 동기화 (Shared RAM)
여러 코어가 동일한 메모리를 접근할 때 생기는 경쟁 조건(Race Condition)을 다음 방식으로 방지할 수 있습니다.

#### (1) Lock으로 동기화합니다.
Spinlock 또는 Mutex를 사용하여 임계 구역을 보호합니다.
짧은 시간 동안 보호가 필요한 구간에 적합합니다.
```C
IfxCpu_acquireMutex();
...
IfxCpu_releaseMutex();
```
> 실제적 예시가 필요

#### (2) Atomic 연산을 합니다.
읽기-수정-쓰기(Read-Modify-Write)를 하나의 원자 동작으로 수행합니다.
예를 들어 카운터 증가, 플래그 업데이트는 락 없이도 데이터 무결성을 유지할 수 있습니다. 
> C에서도 지원하는 아토믹 연산이 있는건지, 임베디드 개발자가 어떻게 할 수 있는지? 이건 하드웨어의 영역이 아닌지

#### (3) Memory Barrier를 사용합니다.
메모리 접근 순서를 강제하여 다음 같은 문제를 방지합니다: `플래그는 먼저 보이지만, 데이터는 아직 반영되지 않은 상태`

Barrier는 “쓰기 완료 후 신호 전달” 같은 동기화 시점에 사용됩니다.

### 3) 주변장치 공유 (Preipheral Ownership)
여러 코어가 하나의 주변장치를 동시에 제어하는 것은 위험하므로, 일반적으로 Owner Core 개념을 사용합니다.
* CAN → CPU2 전담
* UART Shell → CPU0 전담
* PWM → CPU1 전담

이 때, CPU는 자신이 전담하지 않는 레지스터 접근 시, 직접 레지스터 접근 대신 메시지 또는 인터럽트를 통해 전담 CPU로 요청합니다. 
> 어떻게 CPU간 전담 주변장치 정보를 주고받는지 코드로


## 3. Harvard 구조 + TCM 결합
TriCore는 Modified Harvard Architecture를 사용합니다.
> Harvard 구조는 명령어 버스와 데이터 버스를 분리하여, 명령어 Fetch와 데이터 Load/Store을 동시에 수행할 수 있습니다. 이는 파이프라인 효율을 크게 향상시킵니다.

### TCM (Tightly Coupled Memory)
Flash 메모리는 접근 지연이 크고 예측이 어렵기 때문에, TriCore는 CPU에 직접 연결된 고속 메모리인 TCM을 제공합니다. (따라서 CPU와 TCM은 직접 연결되어 전용 로컬 버스를 사용합니다.)
TCM은 다음 영역으로 나뉘어지며, 개발자는 링커 스크립트나 c파일에서 섹션을 분리하는 등 작성할 수 있습니다. 
* **P-TCM (Program TCM)**: ISR, 제어 루프, 안전 루틴과 같은 핵심 코드를 저장합니다. 
* **D-TCM (Data TCM)**: ISR 공유 변수, 제어 루프 반복 데이터를 저장합니다. 

TCM은 항상 일정한 접근 시간을 제공하므로 실시간 결정성을 보장합니다.

이렇게 Harvard 구조는 병렬성, TCM은 지연 시간의 예측 가능성을 제공합니다.
따라서 TriCore는 메모리 구조와 버스 구조를 함께 설계하여 실시간 제어에 최적화된 실행 환경을 제공합니다.

## 4. Context Save Area (CSA)
CSA는 인터럽트 또는 태스크 전환 시 CPU 레지스터 컨텍스트를 스택 대신 전용 하드웨어 관리 영역에 저장하는 구조입니다.

기존 Stack 방식에는 (1) 메모리 접근 지연에 따른 저장 시간 변동, (2) 중첩 인터럽트 증가 시 Stack overflow 위험, (3) RTOS context switching 성능 한계 문제가 있어서 CSA가 등장했습니다. 

### CSA 구조
CSA는 RAM 내에 고정 크기의 블록 풀 형태로 구성됩니다.
각 CSA Block에는 다음 정보가 저장됩니다.
* Program Counter (PC)
* Program Status Word (PSW)
* General Purpose Registers
* Context Link 정보

TriCore 레지스터 구조는 CSA 저장에 최적화되어 설계되어, 하드웨어 기반 빠른 컨텍스트 전환이 가능합니다.
> stack, csa 둘 다 램에 있는데 뭐가 차이가 난다는건지?

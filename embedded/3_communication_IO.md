# 실제 개념

## 먼저, 통신에 대해서..
임베디드 시스템에서의 통신은 "프로그램 간 메시지 교환"이 아니라, 하드웨어 통신 주변장치(Peripheral) 간 전기 신호 교환으로 이루어진다.

즉, 통신 대상은 사람이 아닌, MCU 내부 통신 Peripheral ↔ 외부 장치의 통신 Peripheral 이다.
예를 들어 UART 통신은 다음과 같은 구조를 가진다.
```
MCU (UART Peripheral)  <->  USB-UART 칩 (UART Peripheral)
```
CPU는 레지스터를 통해 주변장치를 제어할 뿐, 실제 비트 송수신은 하드웨어가 수행한다.

### 통신 구조

#### 1. P2P 구조 (UART)
Point-to-Point 구조는 두 장치가 1:1로 직접 연결되는 형태입니다.
서로 대등한 구조이기 떄문에 송신/수신 측은 방향만 다를 뿐 통신 제어 권한이 고정되어 있지 않습니다. 
따라서 양쪽 모두 독립적으로 송신이 가능합니다.

#### 2. Master-Slave 구조 (SPI, I2C)
통신 제어권이 Master에 집중된 구조입니다. 
* Master 역할: Clock 생성, 통신 시작/종료 제어, Slave 선택
* Slave 역할: Clock이 들어올 때만 반응, Master 요청에만 응답

중요한 점은 Master과 Slave는 송신과 수신자의 구분이 아니라, 타이밍과 제어권 주체의 구분입니다. 
예를 들어 SPI는 Full-Duplex로 Slave도 동시에 송신이 가능합니다.

#### 3. Multi-Master 구조 (CAN. Ethernet)
모든 노드가 Master인 구조로, 모두 송신 시작이 가능합니다.
단, 충돌 가능성이 존재하기 때문에 중재를 위해서 다음 세가지가 필요합니다.
1. 버스 중재: 누가 먼저 전송할지 결정합니다. 
2. 버스 모니터링: 항상 버스 상태를 대기했다가 자기 신호와 실제 버스를 비교합니다.
3. 자동 재시도: 중재에서 패배한 노드는 자동으로 대기했다가 재송신을 시도합니다.

중앙 Master 없이 독립적으로 이벤트를 발생시켜야 하는 (지연이 없어야 하는) 상황에서 필요합니다.
- 에어백 ECU: 즉시 브레이크 ECU로 신호 전송
- 센서 노드: 이벤트 발생 즉시 전송




### 동기와 비동기
소프트웨어에서의 동기/비동기는 "제어 흐름" 관점이지만, 통신에서의 동기/비동기는 비트 타이밍을 어떻게 맞추느냐가 기준입니다. 

#### 1. 비동기 통신 (UART)
공유 클록선을 가지지 않습니다. 따라서, 송신과 수신 측이 동일한 전송 속도(baud rate)를 미리 약속하고, start bit를 기준으로 타이밍을 동기화합니다.
> 즉, 시간 기준을 약속으로 맞춥니다.

#### 2. 동기 통신 (SPI, I2C)
클록선을 물리적으로 공유합니다. Master가 클록을 생성해서 클록선으로 인가하면, Slave는 그 클록에 맞춰서 수신받은 비트들을 즉시 샘플링합니다. 
> 즉, 시가 기준을 물리적인 신호로 공유합니다.

이로 인해 동기 통신이 더 안정적이고, 고속이 가능합니다.

### 통신 방향
통신 방향은 송수신이 동시에 가능한지 여부를 의미합니다.
* **Simplex**: 단방향 통신
* **Half-Duplex (I2C)**: 양방향이 가능하지만 동시는 불가하여, 번갈아 통신
* **Full-Duplex (UART, SPI)**: 양방향 통신

선이 분리되어 있으면 Full-Duplex가 가능하고, 선이 공유되면 Half-Duplex 구조가 됩니다. 

### 전기적 출력 구조
#### 1. Push-Pull 출력 (UART, SPI)
핀 내부에 위/아래로 미는 트랜지스터가 모두 존재하여, 핀이 1도 직접 만들고 0도 직접 만듭니다. 
빠른 상승/하강이 가능하여 고속 통신에 유리하고, 신호가 강합니다.
하지만, 여러 장치가 같은 선을 공유하면 충돌 위험성이 있습니다.
#### 2. Open-Drain 출력 (I2C)
핀이 아래로 당기는 트랜지스터만 갖고 있습니다. 따라서 핀은 LOW만 직접 구동 가능하며, HIGH는 Pull-up 저항에 의해 생성됩니다.
따라서 상승 속도가 느리기 때문에 고속 통신에 한계가 있지만, 여러 장치가 같은 선을 공유해도 안전합니다.

Open-Drain 구조는 다음 기능들을 가능하게 합니다.
* ACK: Slave가 SDA를 LOW로 당겨서 "응답했다" 표현할 수 있습니다.
* Clock Stretching: Slave가 SCL을 LOW로 잡고 "잠시 대기해" 표현할 수 있습니다.
* Arbitration(중재): 멀티 Master에서 충돌없이 승자를 결정할 수 있습니다.
### 공유선 통신 구조
#### 1. P2P (UART)
장치들이 1:1로 직접 연결됩니다. 따라서, 상대를 선택하는 주소/CS 개념이 없습니다.
#### 2. Bus (SPI, I2C)
버스란, 여러 장치가 동일한 신호선을 공유하는 구조입니다.
핀과 배선을 절약할 수 있고, 여러 장치를 연결하기 쉬어서 확장성이 있지만, 충돌 관리가 필요하고, 주소와 선택 매커니즘이 필요합니다. 
또한, 신호 무결성 (노이즈/길이/부하) 관리가 필요합니다.

장치 선택 방식에는 다음 방법이 있습니다.
* CS 라인 기반
    * SPI
* 장치 주소 기반: 특정 장치를 명시적으로 지정하여 목적지가 명확합니다.
    * I2C: Slave 주소
    * Ethernet: MAC 주소, IP 주소
* 메시지 ID 기반: 메시지 구독 개념이라, 모든 노드가 메시지를 수신하고 필요한 노드만 ID 기준으로 필터링하여 처리합니다.
    * CAN
 
#### 3. Multi-Node Bus (CAN, LIN, Ethernet)
여러 노드가 동일한 물리 버스를 공유하는 네트워크 구조입니다.
```
Node A ─┬─ Node B ─┬─ Node C ─┬─ Node D
        │          │          │
=================== BUS ===================
```
* 여러 장치가 동시에 연결되어 있습니다.
* 모든 노드가 버스를 항상 모니터링하고 있습니다.
* 충돌 제어 메커니즘이 필수입니다.
    * **버스 충돌 제어 (Bus Arbitration)**: 여러 노드가 동시에 송신할 때, 둘 중 하나의 방식으로 제어할 수 있습니다.
    1. **Master 기반 충돌 방지(SPI, I2C)**: Master가 통신 타이밍을 통제해서 Slave는 Master 요청에만 응답합니다.
    2. **분산 중재 방식(CAN, Ethernet)**: Master가 없는 구조이기 때문에 하드웨어 기반 중재가 필요합니다.
        * CAN: bit-wise로 ID 우선순위를 기반으로 중재합니다.
        * Ethernet: 스위치 기반으로 충돌을 회피합니다.  
* 프레임 필터링이 필요합니다.
    * 네트워크 통신은 외부 노이즈와 오류 환경에서 동작해야 하므로, Parity 수준을 넘어선 강력한 **프레임 신뢰성 구조**를 사용합니다.
    * CRC, ACK Frame, Error Frame, AUtomatic Retransmission 등 하드웨어 차원에서 오류 검출과 재전송을 자동 처리합니다.


### 직렬 통신과 병렬 통신
#### 1. 병렬 통신
여러 비트를 동시에 여러 선으로 전송합니다. 
순간 대역폭이 높아질 수 있지만, 핀이 많이 필요하고 고속에서는 Skew 문제가 발생합니다. 

주로 외부 메모리 인터페이스, LCD RGB 인터페이스에 사용됩니다.

#### 2. 직렬 통신 (UART, SPI, I2C)
비트를 시간 순서대로 하나씩 전송합니다.
배선이 단순하고 핀도 적게 필요합니다. 
고속 직렬 기술이 적용가능하여 느리지만은 않습니다.








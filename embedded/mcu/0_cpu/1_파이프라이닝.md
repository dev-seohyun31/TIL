# 실제 개념
## 파이프라이닝이란
파이프라이닝(Pipelining)이란, CPU가 하나의 명령어를 완전히 끝낸 뒤 다음 명령어를 처리하는 방식이 아니라, 유휴 상태로 놀고 있는 하드웨어 자원이 없도록 여러 명령어를 처리 단계별로 겹쳐 동시에 실행하는 기술입니다.
따라서 단위 시간당 명령어 수 (처리량)을 늘릴 수 있습니다.

RISC 아키텍처는 이 파이프라이닝을 극대화하기 위해 명령어를 단순하고 규칙적인 형태로 설계했습니다.
이 때문에 RISC는 CISC보다 파이프라이닝 적용에 구조적으로 유리하며, 이것이 높은 처리 효율과 성능의 중요한 이유 중 하나입니다.

RISC가 파이프라이닝에 유리한 이유는 다음과 같습니다.
* 명령어 길이가 고정되어 있다.
  * 다음 명령어의 시작 위치를 계산할 필요 없이 바로 다음 위치를 Fetch 가능
* 명령어 처리 시간이 비교적 균일하다.
  * 특정 명령어만 유독 오래 걸리는 병목이 적음
  * 파이프라인 흐름이 끊기지 않음


## 파이프라이닝의 깊이
CPU는 명령어를 처리할 때, 논리적으로는 다음과 같은 단계로 나눌 수 있습니다.
1. IF: 메모리에서 명령어를 가져옴
2. ID: 명령어를 해석함
3. EX: 연산 수행
4. MEM: 메모리 읽기/쓰기
5. WB: 결과를 레지스터에 기록

이 5단계는 개념적 모델이며, 실제 CPU에서는 각 단계가 물리적으로 더 세분화될 수 있습니다.
* 예: EX → EX1 / EX2 / EX3 (결과적으로 파이프라인 깊이는 5~20단계 이상까지 확장 가능합니다.)

대략적인 경향은 다음과 같습니다.
* 임베디드 MCU: 3~6단계
  * 목표: 예측치보다 늦으면 오작동으로 인해 사고가 날 수 있으므로, 정해진 시간안에 반드시 반응해야 한다.
  * 지표: 최악 실행 시간 (WCET)
* 모바일 / 저전력 CPU: 8~12단계
* 서버 / 고성능 CPU: 12~20단계
  * 목표: 평균적으로 성능이 좋고 빨라야 한다.
  * 지표: 평균 성능 (Latency, Throughout)

### 깊이에 따른 특성
* 파이프라인이 깊을 수록
  * 각 단계의 논리 작업량이 줄어듬
  * 클록 주파수를 높이기 쉬움
  * 이론적인 처리량 증가
  * 하지만, 해저드 발생시 flush 비용 증가
* 파이프라인이 얕을수록
  * 구조가 단순
  * 해저드 처리 비용이 작음
  * 실행 시간 예측이 쉬움
  * 하지만, 클록을 매우 높게 올리기는 어려움

파이프라인의 깊이는 클록 상승으로 얻는 이득과 해저드/flush로 인한 손실이 만나는 지점에서 결정된다.

## 파이프라이닝에서 나오는 문제: 해저드
해저드는 파이프라이닝, 즉 병렬 실행 구조에서 필연적으로 발생하는 부작용입니다.

이는 “피해야 할 오류”라기보다는
발생할 수밖에 있어서 관리해야 하는 문제이며,
컴파일러, 하드웨어, 아키텍처 설계가 역할을 나누어 해결합니다.

### Data Hazard
다음 명령어가 이전 명령어의 결과를 필요로 하는 상황입니다
```
ADD R1, R2, R3
SUB R4, R1, R5
```
* ADD 결과가 아직 레지스터에 쓰여지지 않음
* SUB는 R1이 필요함
* 처리 방법
  * Forwarding (Bypassing): ALU 결과를 바로 다음 명령어로 전달
  * Stall (대기): 결과가 준비될 때까지 파이프라인을 멈춤

### Control Hazard
분기 때문에 다음에 실행할 명령어를 확정하지 못한 상황입니다.
```
BEQ R1, R2, L1
```
* 분기 결과는 Execute 단계에서야 확정
* 그런데 Fetch는 이미 다음 명령어를 가져와야 함
* 처리 방법
  * 분기 결과를 예측하여 다음 명령어를 미리 Fetch/Decode하고 대기 (stall)
  * 예측이 맞으면 그대로 진행. 예측이 틀리면 이미 가져온 명령어를 모두 버림 (flush)

### Structural Hazard 
하드웨어 자원이 부족해 동시에 실행할 수 없는 상황입니다.
```
(ALU가 1개이고, 메모리 포트가 1개)
명령어 A: 메모리 접근
명령어 B: 메모리 접근
```
* 처리 방법
  * 멀티포트 구조가 아니라면
  * 자원이 사용 가능할 때까지 stall

# 내가 이해한 바 
# 개발자 관점에서 신경쓸 점 
1. 평균 성능이 아니라 최악 시간 기준으로 생각한다.
  * 최악의 상황에도 시간 안에 끝나는지가 중요하므로, 복잡한 분기를 피하고 입력에 따라 실행시간이 크게 달라지는 코드는 피한다.   
2. 분기 변동성이 많을수록 파이프라인의 flush 발생 가능성이 높으므로, 상태머신 형태로 단순화한다.
  * 분기가 많은 코드 예시:
    ```C
    void loop() {
      if (sensor > 100) {
          doA();
      } else if (error_flag) {
          doB();
      } else if (rx_ready) {
          doC();
      }
    }
    ```
    * 매 반복마다 외부 입력에 따라 조건이 달라지고, 결과도 달라진다.
    * 분기 방향이 불규칙하다. 
  * 상태머신 코드 예시
    ```C
    typedef enum {
      STATE_IDLE,
      STATE_RUN,
      STATE_ERROR
    } State;

    void loop() {
      switch (state) {
          case STATE_IDLE:
              handle_idle();
              state = STATE_RUN;
              break;
  
          case STATE_RUN:
              handle_run();
              state = STATE_IDLE;
              break;
          case STATE_ERROR:
              handle_error();
              break;
      }
    }
    ```
    * 여전히 분기와 if 문이 있어보이지만, `IDLE -> RUN -> IDLE -> RUN` 패턴이 반복되어 분기 방향이 예측 가능하다. 
3. 메모리 접근하는 Load / Store 단계에서 stall이 무조건 발생하므로, 전역 변수 접근을 최소화하고 volatile을 남발하지 않고, 레지스터에 유지될 수 있는 코드 구조를 짠다. 
4. 인터럽트 발생 시 파이프라인이 중단되고 컨텍스트가 저장되므로, 잦은 인터럽트를 피한다. 또한, ISR을 함수가 아니라 비동기 이벤트 알림이라고 생각한다. 
5. MCU는 단순 파이프라인 모델이기 때문에 코드 구조가 타이밍에 그대로 반영될 가능성이 크다. 어셈블리 레벨에서 최소한 읽을 수 있어야 하고, 컴파일 옵션 (-O2, -O3, size vs speed)을 이해해야하고, 인라인/루프 구조에 민감해야 한다. (왜????)
6. 인터럽트, 공유자원 설계에 더 보수적이어야 한다. (왜???)

# 기술지원/고객 대응 관점에서 신경쓸 점 
# 개선된 점 / 깨달음

  

# 실제 개념
## 특권모드란
특권 모드란, CPU가 “이 명령어와 자원에 누가 접근할 수 있는가”를 하드웨어 차원에서 강제하는 실행 규칙입니다.
특권 모드는 상태 레지스터의 한 비트로 표현되지만, 그 비트를 기준으로 명령어 실행, 레지스터 접근, 메모리 보호, 인터럽트 처리 규칙이 하드웨어적으로 갈라집니다.
이는 소프트웨어 정책이 아니라, CPU 아키텍처에 포함된 규칙이며, RISC, 파이프라인, 인터럽트 모델과 같은 수준의 개념입니다. (OS 기능이 아닙니다! CPU 아키텍처 규칙이므로, OS는 이 규칙을 활용합니다!)

CPU/MCU는 최소 다음 두 가지 실행 모드를 가집니다. 이 모드는 현재 실행 중인 코드의 권한 레벨을 의미하며, 모드에 따라 실행 가능한 명령어와 접근 가능한 자원이 제한됩니다.
* 유저 모드 (비특권 모드)
* 슈퍼바이저 모드 (특권 모드)

### 1. 유저 모드
유저 모드는 시스템을 직접 망가뜨릴 수 없도록 제한된 권한으로 실행되는 코드입니다.
일반 애플리케이션 로직은 이 모드에서 실행되도록 설계됩니다.
* 가능한 것: 일반 연산, 허용된 영역의 메모리 접근, 함수 호출, 계산
* 불가능한 것: 인터럽트 enable 및 disable, 특수 레지스터 접근, I/O 제어 레지스터 접근, MPU/MMU 설정 변경, 시스템 클록 / 인터럽트 컨트롤러 제어
  * 유저 모드에서 위와 같은 동작을 시도하면, CPU는 이를 허용하지 않고 Trap(예외)을 발생시킵니다.

### 2. 슈퍼바이저 모드
슈퍼바이저 모드는 시스템 전체를 통제할 수 있는 최고 권한의 실행 모드입니다.
CPU 및 하드웨어 자원을 직접 제어할 수 있으며, 시스템 안정성과 안전성에 직결됩니다.
* 가능한 것: 인터럽트 제어, 컨텍스트 전환, MPU/MMU 설정, 하드웨어 레지스터 접근, 모드 전환, 시스템 자원 관리
  * 이 때문에 슈퍼바이저 모드는 남용되면 매우 위험하며, 자동차·산업용 시스템에서는 **ISO 26262**와 같은 안전 규격에 따라 일반 애플리케이션 코드와 분리하는 것이 요구됩니다.

## 모드 전환
특권 모드는 개발자가 임의로 바꾸는 개념이 아니라,
CPU가 정해진 이벤트에서 자동으로 전환합니다.
### 1. 리셋 직후
리셋은 다음과 같은 경우에 발생합니다: `전원 인가, 외부 Reset 핀, Watchdog Timeout, 심각한 Fault 발생`

리셋 발생 시, CPU는 항상 다음 순서를 따릅니다. 
```
Reset 발생
→ CPU 초기 상태
→ Supervisor Mode 진입
→ Startup Code 실행
→ main() 진입
```
즉, 시스템 초기화는 항상 슈퍼바이저 모드에서 시작합니다.

### 2. 인터럽트 발생 시

인터럽트가 발생하면,
CPU는 현재 코드가 유저 모드인지 여부와 관계없이 강제로 슈퍼바이저 모드로 전환합니다.

동작 흐름은 다음과 같습니다.
1. 현재 명령어 완료
2. 파이프라인 flush
3. 현재 컨텍스트 저장 (PC, 상태 레지스터 등)
4. **Supervisor Mode로 전환**
5. 인터럽트 벡터 주소로 점프
6. ISR 실행
7. ISR 종료 시 컨텍스트 복원
8. **원래 모드(User / Supervisor)로 복귀**

따라서 ISR은 항상 슈퍼바이저 모드에서 실행됩니다.
### 3. 시스템 콜(System Call) / Trap
#### 시스템 콜이란
유저 모드 코드가 슈퍼바이저 모드의 기능을 요청하는 공식적인 통로입니다. 아래는 CPU가 직접 제어하며, 개발자가 임의로 모드를 전환하지 않습니다.

* 유저 모드 코드가 특수 명령어 실행
* CPU가 자동으로 Supervisor Mode로 전환
* 지정된 시스템 콜 핸들러 실행
* 처리 후 원래 모드로 복귀

#### Trap이란
CPU가 규칙 위반이나 오류를 감지했을 때 발생시키는 강제 예외입니다.
* 예: 권한 위반, 0으로 나누기, 잘못된 명령어 실행, 시스템 콜 역시 Trap의 한 종류
* Trap 발생 시 CPU는 현재 흐름을 중단하고 슈퍼바이저 모드로 전환하여 지정된 Trap 핸들러로 진입합니다.


# 내가 이해한 바 
# 개발자 관점에서 신경쓸 점
## 1. 어떤 코드가 어떤 모드에서 도는지 의식한다. 
* Startup, ISR: 슈퍼바이저 모드
* Application logic: 유저 모드
```C
#include "IfxCpu.h"
#include "IfxScuWdt.h"

static void init_hw_supervisor(void)
{
    // Supervisor에서만 해야 하는 초기화
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    // Clock/PLL, 보호 레지스터 설정, MMU/MPU 설정 등...
}

static void switch_to_user_mode(void)
{
    // User mode로 내려가는 단계
    IfxCpu_switchToUserMode();  // 예시용
}

int core0_main(void)
{
    IfxCpu_enableInterrupts();     // 보통 여기서부터 준비 (여전히 Supervisor)
    init_hw_supervisor();
    switch_to_user_mode();         // 초기화 단계에만 특권을 쓰고, 이후는 제한된 권한으로 안정성을 챙김

    while (1)
    {
        app_loop();                // 이후는 User에서 돈다고 가정
    }
}
```

## 2. 유저 모드에서 금지된 작업
* 직접 레지스터 접근
* 인터럽트 enable/disable
* MMU/MPU 설정

이를 유저 모드에서 실행 시, Trap이 발생하여 시스템이 멈추건나, 리셋될 수도 있다.
```C
void app_loop(void)
{
    // User 모드에서 특권 레지스터 조작 시도
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());

    // ...
}
```
특권 작업은 슈퍼바이저에만 몰아넣는다. 
```C
static void init_hw_supervisor(void)
{
    // 여기서만 Watchdog/Clock 같은 특권 작업 수행
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
}

void app_loop(void)
{
    // 앱은 하드웨어 레지스터 직접 만지는 범위를 최소화
    do_business_logic();
}
```

## 3. 모드 전환은 명시적으로 한다. 

# 기술지원/고객 대응 관점에서 신경쓸 점
# 개선된 점 / 깨달음

